{"ast":null,"code":"var TOTALNUMOFCOLUMNS = 7;\nvar TOTALNUMOFROWS = 6;\nvar TOTALNUMOFSQUARES = 42;\n\nfunction findLegalSquare(board, idx) {\n  /**\n   * Returns the index of a legal square that can be filled.\n   * Note the legal square will be within the same column as idx.\n   * If all the squares within idx's column are filled, then this function returns -1.\n   */\n  var didNotFindLegalSquareIdx = -1;\n  var traversingIdx = idx;\n\n  while (traversingIdx - TOTALNUMOFCOLUMNS >= 0) {\n    traversingIdx -= TOTALNUMOFCOLUMNS;\n  }\n\n  for (traversingIdx; traversingIdx < TOTALNUMOFSQUARES; traversingIdx += TOTALNUMOFCOLUMNS) {\n    if (board[traversingIdx] === null) {\n      return traversingIdx;\n    }\n  }\n\n  return didNotFindLegalSquareIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, player, opposingPlayer) {\n  /**\n   * Returns the score for the given arr, assuming the length of the arr is 4\n   */\n  var score = 0;\n\n  if (arr.filter(function (val) {\n    return val === player;\n  }).length === 4) {\n    score += 100;\n  } else if (arr.filter(function (val) {\n    return val === player;\n  }).length === 3 && arr.filter(function (val) {\n    return val === null;\n  }).length === 1) {\n    score += 5;\n  } else if (arr.filter(function (val) {\n    return val === player;\n  }).length === 2 && arr.filter(function (val) {\n    return val === null;\n  }).length === 2) {\n    score += 2;\n  }\n\n  if (arr.filter(function (val) {\n    return val === opposingPlayer;\n  }).length === 3 && arr.filter(function (val) {\n    return val === null;\n  }).length === 1) {\n    score -= 15;\n  }\n\n  return score;\n}\n\nfunction calculateScoreForMove(board, idx, player, opposingPlayer) {\n  /**\n   * Returns the score for placing player's piece onto the board whose location is idx.\n   */\n  var score = 0;\n  var WINDOWLENGTH = 4;\n  var CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n  var newBoard = board.slice();\n  newBoard[idx] = player; // score for center piece (preference center location)\n\n  for (var i = CENTERCOLUMNIDX; i < TOTALNUMOFSQUARES; i += TOTALNUMOFCOLUMNS) {\n    if (newBoard[i] === player) {\n      score += 2;\n    }\n  } // Score for horizontal\n  // Scores are calculated for window lengths of 4\n\n\n  for (var currRowIdx = 0; currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n    for (var _i = 0; _i <= TOTALNUMOFCOLUMNS - WINDOWLENGTH; _i++) {\n      var horizontalFourAdjacentSquares = newBoard.slice(currRowIdx + _i, currRowIdx + _i + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Score for vertical\n  // Scores are calculated for window lengths of 4\n\n\n  for (var currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n    var aColumnOfSquaresArr = [];\n\n    for (var _i2 = currColIdx; _i2 < TOTALNUMOFSQUARES; _i2 += TOTALNUMOFCOLUMNS) {\n      // gets the stack of squares in the given column denoted by currColIdx\n      aColumnOfSquaresArr.push(newBoard[_i2]);\n    }\n\n    for (var _i3 = 0; _i3 <= TOTALNUMOFROWS - WINDOWLENGTH; _i3++) {\n      var verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(_i3, _i3 + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Score for diagonal\n  // Scores are calculated for window lengths of 4\n  // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); _currRowIdx >= 0; _currRowIdx -= TOTALNUMOFCOLUMNS) {\n    var aDiagonalOfSquaresArr = []; // assemble the diagonal of squares arr for the given currRowIdx\n\n    for (var _i4 = 0; _currRowIdx + _i4 * TOTALNUMOFCOLUMNS + _i4 < TOTALNUMOFSQUARES; _i4++) {\n      aDiagonalOfSquaresArr.push(newBoard[_currRowIdx + _i4 * TOTALNUMOFCOLUMNS + _i4]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (var _i5 = 0; _i5 <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; _i5++) {\n      var diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(_i5, _i5 + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx2 = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2); _currRowIdx2 < TOTALNUMOFSQUARES; _currRowIdx2 += TOTALNUMOFCOLUMNS) {\n    var _aDiagonalOfSquaresArr = []; // assemble the diagonal of squares arr for the given currRowIdx\n\n    for (var _i6 = 0; _currRowIdx2 - _i6 * TOTALNUMOFCOLUMNS - _i6 >= 0; _i6++) {\n      _aDiagonalOfSquaresArr.push(newBoard[_currRowIdx2 - _i6 * TOTALNUMOFCOLUMNS - _i6]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (var _i7 = 0; _i7 <= _aDiagonalOfSquaresArr.length - WINDOWLENGTH; _i7++) {\n      var _diagonalFourAdjacentSquares = _aDiagonalOfSquaresArr.slice(_i7, _i7 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx3 = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2); _currRowIdx3 < TOTALNUMOFSQUARES; _currRowIdx3 += TOTALNUMOFCOLUMNS) {\n    var _aDiagonalOfSquaresArr2 = []; // assemble the diagonal of squares arr for the given currRowIdx\n\n    for (var _i8 = 0; _currRowIdx3 - _i8 * TOTALNUMOFCOLUMNS + _i8 >= 0; _i8++) {\n      _aDiagonalOfSquaresArr2.push(newBoard[_currRowIdx3 - _i8 * TOTALNUMOFCOLUMNS + _i8]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (var _i9 = 0; _i9 <= _aDiagonalOfSquaresArr2.length - WINDOWLENGTH; _i9++) {\n      var _diagonalFourAdjacentSquares2 = _aDiagonalOfSquaresArr2.slice(_i9, _i9 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares2, player, opposingPlayer);\n    }\n  }\n\n  return score;\n}\n\nfunction calculateWinner(board, lastSquareIdx) {\n  /**\n   * Returns the name of the winner HUMAN or AI. Else returns null.\n   */\n  // Check horizontal\n  var frontOfcurrRowIdxIdx = lastSquareIdx - lastSquareIdx % TOTALNUMOFCOLUMNS;\n  var currRowIdxIdx = frontOfcurrRowIdxIdx;\n  var howManyConsecutiveCounter = 1; // always starts at 1 because each piece counts as one consecutive piece\n\n  for (currRowIdxIdx; currRowIdxIdx < frontOfcurrRowIdxIdx + TOTALNUMOFCOLUMNS; currRowIdxIdx++) {\n    if (howManyConsecutiveCounter === 4) {\n      return board[currRowIdxIdx]; // winner has been found, return the winner\n    } else if (currRowIdxIdx + 1 < frontOfcurrRowIdxIdx + TOTALNUMOFCOLUMNS && board[currRowIdxIdx] !== null && board[currRowIdxIdx] === board[currRowIdxIdx + 1]) {\n      howManyConsecutiveCounter++;\n    } else {\n      // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n      howManyConsecutiveCounter = 1;\n    }\n  } // Check vertical\n\n\n  var currColIdx = lastSquareIdx % TOTALNUMOFCOLUMNS;\n  var outOfBoundsIdx = TOTALNUMOFSQUARES;\n  howManyConsecutiveCounter = 1; // always starts at 1 because each piece counts as one consecutive piece\n\n  for (currColIdx; currColIdx < outOfBoundsIdx; currColIdx += TOTALNUMOFCOLUMNS) {\n    if (howManyConsecutiveCounter === 4) {\n      return board[currColIdx]; // winner has been found, return the winner\n    } else if (currColIdx + TOTALNUMOFCOLUMNS < outOfBoundsIdx && board[currColIdx] !== null && board[currColIdx] === board[currColIdx + TOTALNUMOFCOLUMNS]) {\n      howManyConsecutiveCounter++;\n    } else {\n      // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n      howManyConsecutiveCounter = 1;\n    }\n  } // Check Diagonal\n  // start with BOTTOM-LEFT TO TOP-RIGHT relative to the lastSquareIdx\n  // get bottom left squares as indices\n\n\n  var rightColumnIdx = new Set([6, 13, 20, 27, 34, 41]);\n  var leftColumnIdx = new Set([0, 7, 14, 21, 28, 35]);\n  var bottomLeftTopRightIdx = [];\n  var i = 1;\n\n  while (lastSquareIdx - TOTALNUMOFCOLUMNS * i >= 0) {\n    if (lastSquareIdx - TOTALNUMOFCOLUMNS * i - i >= 0 && !rightColumnIdx.has(lastSquareIdx - TOTALNUMOFCOLUMNS * i - i)) {\n      bottomLeftTopRightIdx.unshift(lastSquareIdx - TOTALNUMOFCOLUMNS * i - i);\n      i++;\n    } else {\n      break;\n    }\n  } // push the selectedSquareIdx into the bottomLeftTopRightIdx array\n\n\n  bottomLeftTopRightIdx.push(lastSquareIdx); // get the top right squares as indices\n\n  i = 1;\n\n  while (lastSquareIdx + TOTALNUMOFCOLUMNS * i < TOTALNUMOFSQUARES) {\n    if (lastSquareIdx + TOTALNUMOFCOLUMNS * i + i < TOTALNUMOFSQUARES && !leftColumnIdx.has(lastSquareIdx + TOTALNUMOFCOLUMNS * i + i)) {\n      bottomLeftTopRightIdx.push(lastSquareIdx + TOTALNUMOFCOLUMNS * i + i);\n      i++;\n    } else {\n      break;\n    }\n  } // check to see if there is a 4-in-a-row from bottom left to top right\n\n\n  howManyConsecutiveCounter = 1;\n\n  for (var _i10 = 0; _i10 < bottomLeftTopRightIdx.length; _i10++) {\n    if (howManyConsecutiveCounter === 4) {\n      return board[bottomLeftTopRightIdx[_i10]]; // winner has been found, return the winner\n    } else if (board[bottomLeftTopRightIdx[_i10]] !== null && board[bottomLeftTopRightIdx[_i10]] === board[bottomLeftTopRightIdx[_i10 + 1]]) {\n      howManyConsecutiveCounter++;\n    } else {\n      // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n      howManyConsecutiveCounter = 1;\n    }\n  } // NOW DO THE OTHER DIAGONAL... BOTTOM-RIGHT TO TOP-LEFT relative to the lastSquareIdx\n  // get bottom right squares as indices\n\n\n  var bottomRightTopLeftIdx = [];\n  i = 1;\n\n  while (lastSquareIdx - TOTALNUMOFCOLUMNS * i >= 0) {\n    if (!leftColumnIdx.has(lastSquareIdx - TOTALNUMOFCOLUMNS * i + i)) {\n      bottomRightTopLeftIdx.unshift(lastSquareIdx - TOTALNUMOFCOLUMNS * i + i);\n      i++;\n    } else {\n      break;\n    }\n  } // push the selectedSquareIdx into the bottomRightTopLeftIdx array\n\n\n  bottomRightTopLeftIdx.push(lastSquareIdx); // get the top left squares as indices\n\n  i = 1;\n\n  while (lastSquareIdx + TOTALNUMOFCOLUMNS * i < TOTALNUMOFSQUARES) {\n    if (!rightColumnIdx.has(lastSquareIdx + TOTALNUMOFCOLUMNS * i - i)) {\n      bottomRightTopLeftIdx.push(lastSquareIdx + TOTALNUMOFCOLUMNS * i - i);\n      i++;\n    } else {\n      break;\n    }\n  } // check to see if there is a 4-in-a-row from bottom right to top left\n\n\n  howManyConsecutiveCounter = 1;\n\n  for (var _i11 = 0; _i11 < bottomRightTopLeftIdx.length; _i11++) {\n    if (howManyConsecutiveCounter === 4) {\n      return board[bottomRightTopLeftIdx[_i11]]; // winner has been found, return the winner\n    } else if (board[bottomRightTopLeftIdx[_i11]] !== null && board[bottomRightTopLeftIdx[_i11]] === board[bottomRightTopLeftIdx[_i11 + 1]]) {\n      howManyConsecutiveCounter++;\n    } else {\n      // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n      howManyConsecutiveCounter = 1;\n    }\n  }\n\n  return null;\n}\n\nfunction idxOfMaxOfArr(arr) {\n  var max = arr[0];\n  var maxIdx = 0;\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIdx = i;\n    }\n  }\n\n  return maxIdx;\n}\n\nfunction minimax(board, depth, maximizingPlayer, minimizingPlayer) {\n  /**\n   * minimax algorithm to determine how the ai will make its move\n   * refer to the pseudocode on wikipedia\n   */\n  // get all the possible moves that the player can drop into\n  // this should be an array with the indices\n  var possibleMovesArr = [0, 1, 2, 3, 4, 5, 6].map(function (idx) {\n    return findLegalSquare(board, idx);\n  }).filter(function (idx) {\n    return idx !== -1;\n  });\n  var scoresForPossibleMovesArr = possibleMovesArr.map(function (idx) {\n    return calculateScoreForMove(board, idx, maximizingPlayer, minimizingPlayer);\n  });\n  alert(scoresForPossibleMovesArr);\n  return possibleMovesArr[idxOfMaxOfArr(scoresForPossibleMovesArr)];\n}\n\nexport default minimax;","map":{"version":3,"sources":["/Users/kevintsai/Desktop/resume_website/components/portfolio/connect4/minimax.js"],"names":["TOTALNUMOFCOLUMNS","TOTALNUMOFROWS","TOTALNUMOFSQUARES","findLegalSquare","board","idx","didNotFindLegalSquareIdx","traversingIdx","calculateScoreForThese4Squares","arr","player","opposingPlayer","score","filter","val","length","calculateScoreForMove","WINDOWLENGTH","CENTERCOLUMNIDX","Math","floor","newBoard","slice","i","currRowIdx","horizontalFourAdjacentSquares","currColIdx","aColumnOfSquaresArr","push","verticalFourAdjacentSquares","aDiagonalOfSquaresArr","diagonalFourAdjacentSquares","calculateWinner","lastSquareIdx","frontOfcurrRowIdxIdx","currRowIdxIdx","howManyConsecutiveCounter","outOfBoundsIdx","rightColumnIdx","Set","leftColumnIdx","bottomLeftTopRightIdx","has","unshift","bottomRightTopLeftIdx","idxOfMaxOfArr","max","maxIdx","minimax","depth","maximizingPlayer","minimizingPlayer","possibleMovesArr","map","scoresForPossibleMovesArr","alert"],"mappings":"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","sourcesContent":["const TOTALNUMOFCOLUMNS = 7;\nconst TOTALNUMOFROWS = 6;\nconst TOTALNUMOFSQUARES = 42;\n\nfunction findLegalSquare(board, idx) {\n    /**\n     * Returns the index of a legal square that can be filled.\n     * Note the legal square will be within the same column as idx.\n     * If all the squares within idx's column are filled, then this function returns -1.\n     */\n    const didNotFindLegalSquareIdx = -1;\n    let traversingIdx = idx;\n    while (traversingIdx - TOTALNUMOFCOLUMNS >= 0) {\n        traversingIdx -= TOTALNUMOFCOLUMNS;\n    }\n    for (traversingIdx; traversingIdx < TOTALNUMOFSQUARES; traversingIdx += TOTALNUMOFCOLUMNS) {\n        if (board[traversingIdx] === null) {\n            return traversingIdx;\n        }\n    }\n    return didNotFindLegalSquareIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, player, opposingPlayer) {\n    /**\n     * Returns the score for the given arr, assuming the length of the arr is 4\n     */\n\n    let score = 0;\n\n    if (arr.filter(val => val === player).length === 4) {\n        score += 100;\n    } else if (arr.filter(val => val === player).length === 3 && arr.filter(val => val === null).length === 1) {\n        score += 5;\n    } else if (arr.filter(val => val === player).length === 2 && arr.filter(val => val === null).length === 2) {\n        score += 2;\n    }\n\n    if (arr.filter(val => val === opposingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score -= 15;\n    }\n\n    return score;\n}\n\nfunction calculateScoreForMove(board, idx, player, opposingPlayer) {\n    /**\n     * Returns the score for placing player's piece onto the board whose location is idx.\n     */\n\n    let score = 0;\n    const WINDOWLENGTH = 4;\n    const CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n    const newBoard = board.slice();\n    newBoard[idx] = player;\n\n    // score for center piece (preference center location)\n    for (let i = CENTERCOLUMNIDX; i < TOTALNUMOFSQUARES; i += TOTALNUMOFCOLUMNS) {\n        if (newBoard[i] === player) {\n            score += 2;\n        }\n    }\n\n\n    // Score for horizontal\n    // Scores are calculated for window lengths of 4\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n        for (let i = 0; i <= TOTALNUMOFCOLUMNS - WINDOWLENGTH; i++) {\n            const horizontalFourAdjacentSquares = newBoard.slice(currRowIdx + i, currRowIdx + i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, player, opposingPlayer);\n        }\n\n    }\n\n    // Score for vertical\n    // Scores are calculated for window lengths of 4\n    for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n        const aColumnOfSquaresArr = [];\n        for (let i = currColIdx; i < TOTALNUMOFSQUARES; i += TOTALNUMOFCOLUMNS) { // gets the stack of squares in the given column denoted by currColIdx\n            aColumnOfSquaresArr.push(newBoard[i]);\n        }\n        for (let i = 0; i <= TOTALNUMOFROWS - WINDOWLENGTH; i++) {\n            const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, player, opposingPlayer);\n        }\n\n    }\n\n    // Score for diagonal\n    // Scores are calculated for window lengths of 4\n\n    // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); currRowIdx >= 0; currRowIdx -= TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currRowIdx\n        for (let i = 0; currRowIdx + i * TOTALNUMOFCOLUMNS + i < TOTALNUMOFSQUARES; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currRowIdx + i * TOTALNUMOFCOLUMNS + i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currRowIdx\n        for (let i = 0; currRowIdx - i * TOTALNUMOFCOLUMNS - i >= 0; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currRowIdx - i * TOTALNUMOFCOLUMNS - i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currRowIdx\n        for (let i = 0; currRowIdx - i * TOTALNUMOFCOLUMNS + i >= 0; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currRowIdx - i * TOTALNUMOFCOLUMNS + i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    return score;\n}\n\nfunction calculateWinner(board, lastSquareIdx) {\n    /**\n     * Returns the name of the winner HUMAN or AI. Else returns null.\n     */\n\n    // Check horizontal\n    const frontOfcurrRowIdxIdx = lastSquareIdx - (lastSquareIdx % TOTALNUMOFCOLUMNS);\n    let currRowIdxIdx = frontOfcurrRowIdxIdx;\n    let howManyConsecutiveCounter = 1; // always starts at 1 because each piece counts as one consecutive piece\n    for (currRowIdxIdx; currRowIdxIdx < frontOfcurrRowIdxIdx + TOTALNUMOFCOLUMNS; currRowIdxIdx++) {\n        if (howManyConsecutiveCounter === 4) {\n            return board[currRowIdxIdx]; // winner has been found, return the winner\n        } else if (currRowIdxIdx + 1 < frontOfcurrRowIdxIdx + TOTALNUMOFCOLUMNS && board[currRowIdxIdx] !== null && board[currRowIdxIdx] === board[currRowIdxIdx + 1]) {\n            howManyConsecutiveCounter++;\n        } else {\n            // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n            howManyConsecutiveCounter = 1;\n        }\n    }\n\n    // Check vertical\n    let currColIdx = lastSquareIdx % TOTALNUMOFCOLUMNS;\n    const outOfBoundsIdx = TOTALNUMOFSQUARES;\n    howManyConsecutiveCounter = 1; // always starts at 1 because each piece counts as one consecutive piece\n    for (currColIdx; currColIdx < outOfBoundsIdx ; currColIdx += TOTALNUMOFCOLUMNS) {\n        if (howManyConsecutiveCounter === 4) {\n            return board[currColIdx]; // winner has been found, return the winner\n        } else if (currColIdx + TOTALNUMOFCOLUMNS < outOfBoundsIdx && board[currColIdx] !== null && board[currColIdx] === board[currColIdx + TOTALNUMOFCOLUMNS]) {\n            howManyConsecutiveCounter++;\n        } else {\n            // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n            howManyConsecutiveCounter = 1;\n        }\n    }\n\n    // Check Diagonal\n\n    // start with BOTTOM-LEFT TO TOP-RIGHT relative to the lastSquareIdx\n    // get bottom left squares as indices\n    const rightColumnIdx = new Set([6, 13, 20, 27, 34, 41]);\n    const leftColumnIdx = new Set([0, 7, 14, 21, 28, 35]);\n    const bottomLeftTopRightIdx = [];\n    let i = 1;\n    while (lastSquareIdx - TOTALNUMOFCOLUMNS * i >= 0) {\n        if (lastSquareIdx - TOTALNUMOFCOLUMNS * i - i >= 0 && !rightColumnIdx.has(lastSquareIdx - TOTALNUMOFCOLUMNS * i - i)) {\n            bottomLeftTopRightIdx.unshift(lastSquareIdx - TOTALNUMOFCOLUMNS * i - i);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    // push the selectedSquareIdx into the bottomLeftTopRightIdx array\n    bottomLeftTopRightIdx.push(lastSquareIdx);\n\n    // get the top right squares as indices\n    i = 1;\n    while (lastSquareIdx + TOTALNUMOFCOLUMNS * i < TOTALNUMOFSQUARES) {\n        if (lastSquareIdx + TOTALNUMOFCOLUMNS * i + i < TOTALNUMOFSQUARES && !leftColumnIdx.has(lastSquareIdx + TOTALNUMOFCOLUMNS * i + i)) {\n            bottomLeftTopRightIdx.push(lastSquareIdx + TOTALNUMOFCOLUMNS * i + i);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    // check to see if there is a 4-in-a-row from bottom left to top right\n    howManyConsecutiveCounter = 1;\n    for (let i = 0; i < bottomLeftTopRightIdx.length; i++) {\n        if (howManyConsecutiveCounter === 4) {\n            return board[bottomLeftTopRightIdx[i]]; // winner has been found, return the winner\n        } else if (board[bottomLeftTopRightIdx[i]] !== null && board[bottomLeftTopRightIdx[i]] === board[bottomLeftTopRightIdx[i + 1]]) {\n            howManyConsecutiveCounter++;\n        } else {\n            // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n            howManyConsecutiveCounter = 1;\n        }\n    }\n\n    // NOW DO THE OTHER DIAGONAL... BOTTOM-RIGHT TO TOP-LEFT relative to the lastSquareIdx\n    // get bottom right squares as indices\n    const bottomRightTopLeftIdx = [];\n    i = 1;\n    while (lastSquareIdx - TOTALNUMOFCOLUMNS * i >= 0) {\n        if (!leftColumnIdx.has(lastSquareIdx - TOTALNUMOFCOLUMNS * i + i)) {\n            bottomRightTopLeftIdx.unshift(lastSquareIdx - TOTALNUMOFCOLUMNS * i + i);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    // push the selectedSquareIdx into the bottomRightTopLeftIdx array\n    bottomRightTopLeftIdx.push(lastSquareIdx);\n\n    // get the top left squares as indices\n    i = 1;\n    while (lastSquareIdx + TOTALNUMOFCOLUMNS * i < TOTALNUMOFSQUARES) {\n        if (!rightColumnIdx.has(lastSquareIdx + TOTALNUMOFCOLUMNS * i - i)) {\n            bottomRightTopLeftIdx.push(lastSquareIdx + TOTALNUMOFCOLUMNS * i - i);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    // check to see if there is a 4-in-a-row from bottom right to top left\n    howManyConsecutiveCounter = 1;\n    for (let i = 0; i < bottomRightTopLeftIdx.length; i++) {\n        if (howManyConsecutiveCounter === 4) {\n            return board[bottomRightTopLeftIdx[i]]; // winner has been found, return the winner\n        } else if (board[bottomRightTopLeftIdx[i]] !== null && board[bottomRightTopLeftIdx[i]] === board[bottomRightTopLeftIdx[i + 1]]) {\n            howManyConsecutiveCounter++;\n        } else {\n            // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n            howManyConsecutiveCounter = 1;\n        }\n    }\n\n    return null;\n}\n\nfunction idxOfMaxOfArr(arr) {\n    let max = arr[0];\n    let maxIdx = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] > max) {\n            max = arr[i]\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n\nfunction minimax(board, depth, maximizingPlayer, minimizingPlayer) {\n    /**\n     * minimax algorithm to determine how the ai will make its move\n     * refer to the pseudocode on wikipedia\n     */\n\n    // get all the possible moves that the player can drop into\n    // this should be an array with the indices\n    const possibleMovesArr = [0,1,2,3,4,5,6].map(idx => findLegalSquare(board, idx)).filter(idx => idx !== -1);\n    const scoresForPossibleMovesArr = possibleMovesArr.map(idx => calculateScoreForMove(board, idx, maximizingPlayer, minimizingPlayer));\n    alert(scoresForPossibleMovesArr);\n    return possibleMovesArr[idxOfMaxOfArr(scoresForPossibleMovesArr)];\n}\n\nexport default minimax;"]},"metadata":{},"sourceType":"module"}