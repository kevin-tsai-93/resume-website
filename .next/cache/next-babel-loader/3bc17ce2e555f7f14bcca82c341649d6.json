{"ast":null,"code":"var TOTALNUMOFCOLUMNS = 7;\nvar TOTALNUMOFROWS = 6;\nvar TOTALNUMOFSQUARES = 42;\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n  /**\n   * Returns the row index of a legal square that can be filled.\n   * Note the legal square will be within the same column as selectedColIdx.\n   * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n   */\n  var didNotFindLegalRowIdxWithinColumnIdx = -1;\n\n  for (var rowIdx = 0; rowIdx < this.state.squares.length; rowIdx++) {\n    if (this.state.squares[rowIdx][selectedColIdx] === null) {\n      return rowIdx;\n    }\n  }\n\n  return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction findLegalSquare(board, idx) {\n  /**\n   * Returns the index of a legal square that can be filled.\n   * Note the legal square will be within the same column as idx.\n   * If all the squares within idx's column are filled, then this function returns -1.\n   */\n  var didNotFindLegalSquareIdx = -1;\n  var traversingIdx = idx;\n\n  while (traversingIdx - TOTALNUMOFCOLUMNS >= 0) {\n    traversingIdx -= TOTALNUMOFCOLUMNS;\n  }\n\n  for (traversingIdx; traversingIdx < TOTALNUMOFSQUARES; traversingIdx += TOTALNUMOFCOLUMNS) {\n    if (board[traversingIdx] === null) {\n      return traversingIdx;\n    }\n  }\n\n  return didNotFindLegalSquareIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, player, opposingPlayer) {\n  /**\n   * Returns the score for the given arr, assuming the length of the arr is 4\n   */\n  var score = 0;\n\n  if (arr.filter(function (val) {\n    return val === player;\n  }).length === 4) {\n    score += 100;\n  } else if (arr.filter(function (val) {\n    return val === player;\n  }).length === 3 && arr.filter(function (val) {\n    return val === null;\n  }).length === 1) {\n    score += 5;\n  } else if (arr.filter(function (val) {\n    return val === player;\n  }).length === 2 && arr.filter(function (val) {\n    return val === null;\n  }).length === 2) {\n    score += 2;\n  }\n\n  if (arr.filter(function (val) {\n    return val === opposingPlayer;\n  }).length === 3 && arr.filter(function (val) {\n    return val === null;\n  }).length === 1) {\n    score -= 15;\n  }\n\n  return score;\n}\n\nfunction calculateScoreForMove(board, idx, player, opposingPlayer) {\n  /**\n   * Returns the score for placing player's piece onto the board whose location is idx.\n   */\n  var score = 0;\n  var WINDOWLENGTH = 4;\n  var CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n  var newBoard = board.slice();\n  newBoard[idx] = player; // score for center piece (preference center location)\n\n  for (var i = CENTERCOLUMNIDX; i < TOTALNUMOFSQUARES; i += TOTALNUMOFCOLUMNS) {\n    if (newBoard[i] === player) {\n      score += 2;\n    }\n  } // Score for horizontal\n  // Scores are calculated for window lengths of 4\n\n\n  for (var currRowIdx = 0; currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n    for (var offset = 0; offset <= TOTALNUMOFCOLUMNS - WINDOWLENGTH; offset++) {\n      var horizontalFourAdjacentSquares = newBoard.slice(currRowIdx + offset, currRowIdx + offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Score for vertical\n  // Scores are calculated for window lengths of 4\n\n\n  for (var currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n    var aColumnOfSquaresArr = [];\n\n    for (var _i = currColIdx; _i < TOTALNUMOFSQUARES; _i += TOTALNUMOFCOLUMNS) {\n      // gets the stack of squares in the given column denoted by currColIdx\n      aColumnOfSquaresArr.push(newBoard[_i]);\n    }\n\n    for (var _i2 = 0; _i2 <= TOTALNUMOFROWS - WINDOWLENGTH; _i2++) {\n      var verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(_i2, _i2 + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Score for diagonal\n  // Scores are calculated for window lengths of 4\n  // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var currIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); currIdx >= 0; currIdx -= TOTALNUMOFCOLUMNS) {\n    var aDiagonalOfSquaresArr = []; // assemble the diagonal of squares arr for the given currIdx\n\n    for (var _i3 = 0; currIdx + _i3 * TOTALNUMOFCOLUMNS + _i3 < TOTALNUMOFSQUARES; _i3++) {\n      aDiagonalOfSquaresArr.push(newBoard[currIdx + _i3 * TOTALNUMOFCOLUMNS + _i3]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (var _i4 = 0; _i4 <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; _i4++) {\n      var diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(_i4, _i4 + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currIdx = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2) + TOTALNUMOFCOLUMNS - 1; _currIdx < TOTALNUMOFSQUARES; _currIdx += TOTALNUMOFCOLUMNS) {\n    var _aDiagonalOfSquaresArr = []; // assemble the diagonal of squares arr for the given currIdx\n\n    for (var _i5 = 0; _currIdx - _i5 * TOTALNUMOFCOLUMNS - _i5 >= 0; _i5++) {\n      _aDiagonalOfSquaresArr.push(newBoard[_currIdx - _i5 * TOTALNUMOFCOLUMNS - _i5]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (var _i6 = 0; _i6 <= _aDiagonalOfSquaresArr.length - WINDOWLENGTH; _i6++) {\n      var _diagonalFourAdjacentSquares = _aDiagonalOfSquaresArr.slice(_i6, _i6 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var _currIdx2 = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2); _currIdx2 < TOTALNUMOFSQUARES; _currIdx2 += TOTALNUMOFCOLUMNS) {\n    var _aDiagonalOfSquaresArr2 = []; // assemble the diagonal of squares arr for the given currIdx\n\n    for (var _i7 = 0; _currIdx2 - _i7 * TOTALNUMOFCOLUMNS + _i7 >= 0; _i7++) {\n      _aDiagonalOfSquaresArr2.push(newBoard[_currIdx2 - _i7 * TOTALNUMOFCOLUMNS + _i7]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (var _i8 = 0; _i8 <= _aDiagonalOfSquaresArr2.length - WINDOWLENGTH; _i8++) {\n      var _diagonalFourAdjacentSquares2 = _aDiagonalOfSquaresArr2.slice(_i8, _i8 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares2, player, opposingPlayer);\n    }\n  } // CONTINUE HERE AFTER DINNER\n  // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); _currRowIdx < TOTALNUMOFSQUARES; _currRowIdx += TOTALNUMOFCOLUMNS) {\n    var _aDiagonalOfSquaresArr3 = []; // assemble the diagonal of squares arr for the given currRowIdx\n\n    for (var _i9 = 0; _currRowIdx - _i9 * TOTALNUMOFCOLUMNS + _i9 >= 0; _i9++) {\n      _aDiagonalOfSquaresArr3.push(newBoard[_currRowIdx - _i9 * TOTALNUMOFCOLUMNS + _i9]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (var _i10 = 0; _i10 <= _aDiagonalOfSquaresArr3.length - WINDOWLENGTH; _i10++) {\n      var _diagonalFourAdjacentSquares3 = _aDiagonalOfSquaresArr3.slice(_i10, _i10 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares3, player, opposingPlayer);\n    }\n  }\n\n  return score;\n}\n\nfunction idxOfMaxOfArr(arr) {\n  var max = arr[0];\n  var maxIdx = 0;\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIdx = i;\n    }\n  }\n\n  return maxIdx;\n}\n\nfunction minimax(board, depth, maximizingPlayer, minimizingPlayer) {\n  /**\n   * minimax algorithm to determine how the ai will make its move\n   * refer to the pseudocode on wikipedia\n   */\n  // get all the possible moves that the player can drop into\n  // this should be an array with the indices\n  var possibleMovesArr = [0, 1, 2, 3, 4, 5, 6].map(function (idx) {\n    return findLegalSquare(board, idx);\n  }).filter(function (idx) {\n    return idx !== -1;\n  });\n  var scoresForPossibleMovesArr = possibleMovesArr.map(function (idx) {\n    return calculateScoreForMove(board, idx, maximizingPlayer, minimizingPlayer);\n  });\n  alert(scoresForPossibleMovesArr);\n  return possibleMovesArr[idxOfMaxOfArr(scoresForPossibleMovesArr)];\n}\n\nexport default minimax;","map":{"version":3,"sources":["/Users/kevintsai/Desktop/resume_website/components/portfolio/connect4/minimax.js"],"names":["TOTALNUMOFCOLUMNS","TOTALNUMOFROWS","TOTALNUMOFSQUARES","findLegalRowIdxWithinColumn","board","selectedColIdx","didNotFindLegalRowIdxWithinColumnIdx","rowIdx","state","squares","length","findLegalSquare","idx","didNotFindLegalSquareIdx","traversingIdx","calculateScoreForThese4Squares","arr","player","opposingPlayer","score","filter","val","calculateScoreForMove","WINDOWLENGTH","CENTERCOLUMNIDX","Math","floor","newBoard","slice","i","currRowIdx","offset","horizontalFourAdjacentSquares","currColIdx","aColumnOfSquaresArr","push","verticalFourAdjacentSquares","currIdx","aDiagonalOfSquaresArr","diagonalFourAdjacentSquares","idxOfMaxOfArr","max","maxIdx","minimax","depth","maximizingPlayer","minimizingPlayer","possibleMovesArr","map","scoresForPossibleMovesArr","alert"],"mappings":"AAAA,IAAMA,iBAAiB,GAAG,CAA1B;AACA,IAAMC,cAAc,GAAG,CAAvB;AACA,IAAMC,iBAAiB,GAAG,EAA1B;;AAEA,SAASC,2BAAT,CAAqCC,KAArC,EAA4CC,cAA5C,EAA4D;AACxD;AACJ;AACA;AACA;AACA;AACI,MAAMC,oCAAoC,GAAG,CAAC,CAA9C;;AACA,OAAK,IAAIC,MAAM,GAAG,CAAlB,EAAqBA,MAAM,GAAG,KAAKC,KAAL,CAAWC,OAAX,CAAmBC,MAAjD,EAAyDH,MAAM,EAA/D,EAAmE;AAC/D,QAAI,KAAKC,KAAL,CAAWC,OAAX,CAAmBF,MAAnB,EAA2BF,cAA3B,MAA+C,IAAnD,EAAyD;AACrD,aAAOE,MAAP;AACH;AACJ;;AACD,SAAOD,oCAAP;AACH;;AAED,SAASK,eAAT,CAAyBP,KAAzB,EAAgCQ,GAAhC,EAAqC;AACjC;AACJ;AACA;AACA;AACA;AACI,MAAMC,wBAAwB,GAAG,CAAC,CAAlC;AACA,MAAIC,aAAa,GAAGF,GAApB;;AACA,SAAOE,aAAa,GAAGd,iBAAhB,IAAqC,CAA5C,EAA+C;AAC3Cc,IAAAA,aAAa,IAAId,iBAAjB;AACH;;AACD,OAAKc,aAAL,EAAoBA,aAAa,GAAGZ,iBAApC,EAAuDY,aAAa,IAAId,iBAAxE,EAA2F;AACvF,QAAII,KAAK,CAACU,aAAD,CAAL,KAAyB,IAA7B,EAAmC;AAC/B,aAAOA,aAAP;AACH;AACJ;;AACD,SAAOD,wBAAP;AACH;;AAED,SAASE,8BAAT,CAAwCC,GAAxC,EAA6CC,MAA7C,EAAqDC,cAArD,EAAqE;AACjE;AACJ;AACA;AAEI,MAAIC,KAAK,GAAG,CAAZ;;AAEA,MAAIH,GAAG,CAACI,MAAJ,CAAW,UAAAC,GAAG;AAAA,WAAIA,GAAG,KAAKJ,MAAZ;AAAA,GAAd,EAAkCP,MAAlC,KAA6C,CAAjD,EAAoD;AAChDS,IAAAA,KAAK,IAAI,GAAT;AACH,GAFD,MAEO,IAAIH,GAAG,CAACI,MAAJ,CAAW,UAAAC,GAAG;AAAA,WAAIA,GAAG,KAAKJ,MAAZ;AAAA,GAAd,EAAkCP,MAAlC,KAA6C,CAA7C,IAAkDM,GAAG,CAACI,MAAJ,CAAW,UAAAC,GAAG;AAAA,WAAIA,GAAG,KAAK,IAAZ;AAAA,GAAd,EAAgCX,MAAhC,KAA2C,CAAjG,EAAoG;AACvGS,IAAAA,KAAK,IAAI,CAAT;AACH,GAFM,MAEA,IAAIH,GAAG,CAACI,MAAJ,CAAW,UAAAC,GAAG;AAAA,WAAIA,GAAG,KAAKJ,MAAZ;AAAA,GAAd,EAAkCP,MAAlC,KAA6C,CAA7C,IAAkDM,GAAG,CAACI,MAAJ,CAAW,UAAAC,GAAG;AAAA,WAAIA,GAAG,KAAK,IAAZ;AAAA,GAAd,EAAgCX,MAAhC,KAA2C,CAAjG,EAAoG;AACvGS,IAAAA,KAAK,IAAI,CAAT;AACH;;AAED,MAAIH,GAAG,CAACI,MAAJ,CAAW,UAAAC,GAAG;AAAA,WAAIA,GAAG,KAAKH,cAAZ;AAAA,GAAd,EAA0CR,MAA1C,KAAqD,CAArD,IAA0DM,GAAG,CAACI,MAAJ,CAAW,UAAAC,GAAG;AAAA,WAAIA,GAAG,KAAK,IAAZ;AAAA,GAAd,EAAgCX,MAAhC,KAA2C,CAAzG,EAA4G;AACxGS,IAAAA,KAAK,IAAI,EAAT;AACH;;AAED,SAAOA,KAAP;AACH;;AAED,SAASG,qBAAT,CAA+BlB,KAA/B,EAAsCQ,GAAtC,EAA2CK,MAA3C,EAAmDC,cAAnD,EAAmE;AAC/D;AACJ;AACA;AAEI,MAAIC,KAAK,GAAG,CAAZ;AACA,MAAMI,YAAY,GAAG,CAArB;AACA,MAAMC,eAAe,GAAGC,IAAI,CAACC,KAAL,CAAW1B,iBAAiB,GAAG,CAA/B,CAAxB;AACA,MAAM2B,QAAQ,GAAGvB,KAAK,CAACwB,KAAN,EAAjB;AACAD,EAAAA,QAAQ,CAACf,GAAD,CAAR,GAAgBK,MAAhB,CAT+D,CAW/D;;AACA,OAAK,IAAIY,CAAC,GAAGL,eAAb,EAA8BK,CAAC,GAAG3B,iBAAlC,EAAqD2B,CAAC,IAAI7B,iBAA1D,EAA6E;AACzE,QAAI2B,QAAQ,CAACE,CAAD,CAAR,KAAgBZ,MAApB,EAA4B;AACxBE,MAAAA,KAAK,IAAI,CAAT;AACH;AACJ,GAhB8D,CAmB/D;AACA;;;AACA,OAAK,IAAIW,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAG5B,iBAAtC,EAAyD4B,UAAU,IAAI9B,iBAAvE,EAA0F;AACtF,SAAK,IAAI+B,MAAM,GAAG,CAAlB,EAAqBA,MAAM,IAAI/B,iBAAiB,GAAGuB,YAAnD,EAAiEQ,MAAM,EAAvE,EAA2E;AACvE,UAAMC,6BAA6B,GAAGL,QAAQ,CAACC,KAAT,CAAeE,UAAU,GAAGC,MAA5B,EAAoCD,UAAU,GAAGC,MAAb,GAAsBR,YAA1D,CAAtC;AACAJ,MAAAA,KAAK,IAAIJ,8BAA8B,CAACiB,6BAAD,EAAgCf,MAAhC,EAAwCC,cAAxC,CAAvC;AACH;AACJ,GA1B8D,CA4B/D;AACA;;;AACA,OAAK,IAAIe,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGjC,iBAAtC,EAAyDiC,UAAU,EAAnE,EAAuE;AACnE,QAAMC,mBAAmB,GAAG,EAA5B;;AACA,SAAK,IAAIL,EAAC,GAAGI,UAAb,EAAyBJ,EAAC,GAAG3B,iBAA7B,EAAgD2B,EAAC,IAAI7B,iBAArD,EAAwE;AAAE;AACtEkC,MAAAA,mBAAmB,CAACC,IAApB,CAAyBR,QAAQ,CAACE,EAAD,CAAjC;AACH;;AACD,SAAK,IAAIA,GAAC,GAAG,CAAb,EAAgBA,GAAC,IAAI5B,cAAc,GAAGsB,YAAtC,EAAoDM,GAAC,EAArD,EAAyD;AACrD,UAAMO,2BAA2B,GAAGF,mBAAmB,CAACN,KAApB,CAA0BC,GAA1B,EAA6BA,GAAC,GAAGN,YAAjC,CAApC;AACAJ,MAAAA,KAAK,IAAIJ,8BAA8B,CAACqB,2BAAD,EAA8BnB,MAA9B,EAAsCC,cAAtC,CAAvC;AACH;AAEJ,GAxC8D,CA0C/D;AACA;AAEA;;;AACA,OAAK,IAAImB,OAAO,GAAGrC,iBAAiB,IAAIyB,IAAI,CAACC,KAAL,CAAWzB,cAAc,GAAG,CAA5B,IAAiC,CAArC,CAApC,EAA6EoC,OAAO,IAAI,CAAxF,EAA2FA,OAAO,IAAIrC,iBAAtG,EAAyH;AACrH,QAAMsC,qBAAqB,GAAG,EAA9B,CADqH,CAErH;;AACA,SAAK,IAAIT,GAAC,GAAG,CAAb,EAAgBQ,OAAO,GAAGR,GAAC,GAAG7B,iBAAd,GAAkC6B,GAAlC,GAAsC3B,iBAAtD,EAAyE2B,GAAC,EAA1E,EAA8E;AAC1ES,MAAAA,qBAAqB,CAACH,IAAtB,CAA2BR,QAAQ,CAACU,OAAO,GAAGR,GAAC,GAAG7B,iBAAd,GAAkC6B,GAAnC,CAAnC;AACH,KALoH,CAMrH;;;AACA,SAAK,IAAIA,GAAC,GAAG,CAAb,EAAgBA,GAAC,IAAIS,qBAAqB,CAAC5B,MAAtB,GAA+Ba,YAApD,EAAkEM,GAAC,EAAnE,EAAuE;AACnE,UAAMU,2BAA2B,GAAGD,qBAAqB,CAACV,KAAtB,CAA4BC,GAA5B,EAA+BA,GAAC,GAAGN,YAAnC,CAApC;AACAJ,MAAAA,KAAK,IAAIJ,8BAA8B,CAACwB,2BAAD,EAA8BtB,MAA9B,EAAsCC,cAAtC,CAAvC;AACH;AACJ,GAzD8D,CA2D/D;;;AACA,OAAK,IAAImB,QAAO,GAAIrC,iBAAiB,GAAGyB,IAAI,CAACC,KAAL,CAAWzB,cAAc,GAAG,CAA5B,CAArB,GAAuDD,iBAAvD,GAA2E,CAA9F,EAAiGqC,QAAO,GAAGnC,iBAA3G,EAA8HmC,QAAO,IAAIrC,iBAAzI,EAA4J;AACxJ,QAAMsC,sBAAqB,GAAG,EAA9B,CADwJ,CAExJ;;AACA,SAAK,IAAIT,GAAC,GAAG,CAAb,EAAgBQ,QAAO,GAAGR,GAAC,GAAG7B,iBAAd,GAAkC6B,GAAlC,IAAuC,CAAvD,EAA0DA,GAAC,EAA3D,EAA+D;AAC3DS,MAAAA,sBAAqB,CAACH,IAAtB,CAA2BR,QAAQ,CAACU,QAAO,GAAGR,GAAC,GAAG7B,iBAAd,GAAkC6B,GAAnC,CAAnC;AACH,KALuJ,CAMxJ;;;AACA,SAAK,IAAIA,GAAC,GAAG,CAAb,EAAgBA,GAAC,IAAIS,sBAAqB,CAAC5B,MAAtB,GAA+Ba,YAApD,EAAkEM,GAAC,EAAnE,EAAuE;AACnE,UAAMU,4BAA2B,GAAGD,sBAAqB,CAACV,KAAtB,CAA4BC,GAA5B,EAA+BA,GAAC,GAAGN,YAAnC,CAApC;;AACAJ,MAAAA,KAAK,IAAIJ,8BAA8B,CAACwB,4BAAD,EAA8BtB,MAA9B,EAAsCC,cAAtC,CAAvC;AACH;AACJ,GAvE8D,CAyE/D;;;AACA,OAAK,IAAImB,SAAO,GAAGrC,iBAAiB,GAAGyB,IAAI,CAACC,KAAL,CAAWzB,cAAc,GAAG,CAA5B,CAAvC,EAAuEoC,SAAO,GAAGnC,iBAAjF,EAAoGmC,SAAO,IAAIrC,iBAA/G,EAAkI;AAC9H,QAAMsC,uBAAqB,GAAG,EAA9B,CAD8H,CAE9H;;AACA,SAAK,IAAIT,GAAC,GAAG,CAAb,EAAgBQ,SAAO,GAAGR,GAAC,GAAG7B,iBAAd,GAAkC6B,GAAlC,IAAuC,CAAvD,EAA0DA,GAAC,EAA3D,EAA+D;AAC3DS,MAAAA,uBAAqB,CAACH,IAAtB,CAA2BR,QAAQ,CAACU,SAAO,GAAGR,GAAC,GAAG7B,iBAAd,GAAkC6B,GAAnC,CAAnC;AACH,KAL6H,CAM9H;;;AACA,SAAK,IAAIA,GAAC,GAAG,CAAb,EAAgBA,GAAC,IAAIS,uBAAqB,CAAC5B,MAAtB,GAA+Ba,YAApD,EAAkEM,GAAC,EAAnE,EAAuE;AACnE,UAAMU,6BAA2B,GAAGD,uBAAqB,CAACV,KAAtB,CAA4BC,GAA5B,EAA+BA,GAAC,GAAGN,YAAnC,CAApC;;AACAJ,MAAAA,KAAK,IAAIJ,8BAA8B,CAACwB,6BAAD,EAA8BtB,MAA9B,EAAsCC,cAAtC,CAAvC;AACH;AACJ,GArF8D,CAuF/D;AAEA;;;AACA,OAAK,IAAIY,WAAU,GAAG9B,iBAAiB,IAAIyB,IAAI,CAACC,KAAL,CAAWzB,cAAc,GAAG,CAA5B,IAAiC,CAArC,CAAvC,EAAgF6B,WAAU,GAAG5B,iBAA7F,EAAgH4B,WAAU,IAAI9B,iBAA9H,EAAiJ;AAC7I,QAAMsC,uBAAqB,GAAG,EAA9B,CAD6I,CAE7I;;AACA,SAAK,IAAIT,GAAC,GAAG,CAAb,EAAgBC,WAAU,GAAGD,GAAC,GAAG7B,iBAAjB,GAAqC6B,GAArC,IAA0C,CAA1D,EAA6DA,GAAC,EAA9D,EAAkE;AAC9DS,MAAAA,uBAAqB,CAACH,IAAtB,CAA2BR,QAAQ,CAACG,WAAU,GAAGD,GAAC,GAAG7B,iBAAjB,GAAqC6B,GAAtC,CAAnC;AACH,KAL4I,CAM7I;;;AACA,SAAK,IAAIA,IAAC,GAAG,CAAb,EAAgBA,IAAC,IAAIS,uBAAqB,CAAC5B,MAAtB,GAA+Ba,YAApD,EAAkEM,IAAC,EAAnE,EAAuE;AACnE,UAAMU,6BAA2B,GAAGD,uBAAqB,CAACV,KAAtB,CAA4BC,IAA5B,EAA+BA,IAAC,GAAGN,YAAnC,CAApC;;AACAJ,MAAAA,KAAK,IAAIJ,8BAA8B,CAACwB,6BAAD,EAA8BtB,MAA9B,EAAsCC,cAAtC,CAAvC;AACH;AACJ;;AAED,SAAOC,KAAP;AACH;;AAED,SAASqB,aAAT,CAAuBxB,GAAvB,EAA4B;AACxB,MAAIyB,GAAG,GAAGzB,GAAG,CAAC,CAAD,CAAb;AACA,MAAI0B,MAAM,GAAG,CAAb;;AACA,OAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGb,GAAG,CAACN,MAAxB,EAAgCmB,CAAC,EAAjC,EAAqC;AACjC,QAAIb,GAAG,CAACa,CAAD,CAAH,GAASY,GAAb,EAAkB;AACdA,MAAAA,GAAG,GAAGzB,GAAG,CAACa,CAAD,CAAT;AACAa,MAAAA,MAAM,GAAGb,CAAT;AACH;AACJ;;AACD,SAAOa,MAAP;AACH;;AAED,SAASC,OAAT,CAAiBvC,KAAjB,EAAwBwC,KAAxB,EAA+BC,gBAA/B,EAAiDC,gBAAjD,EAAmE;AAC/D;AACJ;AACA;AACA;AAEI;AACA;AACA,MAAMC,gBAAgB,GAAG,CAAC,CAAD,EAAG,CAAH,EAAK,CAAL,EAAO,CAAP,EAAS,CAAT,EAAW,CAAX,EAAa,CAAb,EAAgBC,GAAhB,CAAoB,UAAApC,GAAG;AAAA,WAAID,eAAe,CAACP,KAAD,EAAQQ,GAAR,CAAnB;AAAA,GAAvB,EAAwDQ,MAAxD,CAA+D,UAAAR,GAAG;AAAA,WAAIA,GAAG,KAAK,CAAC,CAAb;AAAA,GAAlE,CAAzB;AACA,MAAMqC,yBAAyB,GAAGF,gBAAgB,CAACC,GAAjB,CAAqB,UAAApC,GAAG;AAAA,WAAIU,qBAAqB,CAAClB,KAAD,EAAQQ,GAAR,EAAaiC,gBAAb,EAA+BC,gBAA/B,CAAzB;AAAA,GAAxB,CAAlC;AACAI,EAAAA,KAAK,CAACD,yBAAD,CAAL;AACA,SAAOF,gBAAgB,CAACP,aAAa,CAACS,yBAAD,CAAd,CAAvB;AACH;;AAED,eAAeN,OAAf","sourcesContent":["const TOTALNUMOFCOLUMNS = 7;\nconst TOTALNUMOFROWS = 6;\nconst TOTALNUMOFSQUARES = 42;\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n    /**\n     * Returns the row index of a legal square that can be filled.\n     * Note the legal square will be within the same column as selectedColIdx.\n     * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n     */\n    const didNotFindLegalRowIdxWithinColumnIdx = -1;\n    for (let rowIdx = 0; rowIdx < this.state.squares.length; rowIdx++) {\n        if (this.state.squares[rowIdx][selectedColIdx] === null) {\n            return rowIdx;\n        }\n    }\n    return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction findLegalSquare(board, idx) {\n    /**\n     * Returns the index of a legal square that can be filled.\n     * Note the legal square will be within the same column as idx.\n     * If all the squares within idx's column are filled, then this function returns -1.\n     */\n    const didNotFindLegalSquareIdx = -1;\n    let traversingIdx = idx;\n    while (traversingIdx - TOTALNUMOFCOLUMNS >= 0) {\n        traversingIdx -= TOTALNUMOFCOLUMNS;\n    }\n    for (traversingIdx; traversingIdx < TOTALNUMOFSQUARES; traversingIdx += TOTALNUMOFCOLUMNS) {\n        if (board[traversingIdx] === null) {\n            return traversingIdx;\n        }\n    }\n    return didNotFindLegalSquareIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, player, opposingPlayer) {\n    /**\n     * Returns the score for the given arr, assuming the length of the arr is 4\n     */\n\n    let score = 0;\n\n    if (arr.filter(val => val === player).length === 4) {\n        score += 100;\n    } else if (arr.filter(val => val === player).length === 3 && arr.filter(val => val === null).length === 1) {\n        score += 5;\n    } else if (arr.filter(val => val === player).length === 2 && arr.filter(val => val === null).length === 2) {\n        score += 2;\n    }\n\n    if (arr.filter(val => val === opposingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score -= 15;\n    }\n\n    return score;\n}\n\nfunction calculateScoreForMove(board, idx, player, opposingPlayer) {\n    /**\n     * Returns the score for placing player's piece onto the board whose location is idx.\n     */\n\n    let score = 0;\n    const WINDOWLENGTH = 4;\n    const CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n    const newBoard = board.slice();\n    newBoard[idx] = player;\n\n    // score for center piece (preference center location)\n    for (let i = CENTERCOLUMNIDX; i < TOTALNUMOFSQUARES; i += TOTALNUMOFCOLUMNS) {\n        if (newBoard[i] === player) {\n            score += 2;\n        }\n    }\n\n\n    // Score for horizontal\n    // Scores are calculated for window lengths of 4\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n        for (let offset = 0; offset <= TOTALNUMOFCOLUMNS - WINDOWLENGTH; offset++) {\n            const horizontalFourAdjacentSquares = newBoard.slice(currRowIdx + offset, currRowIdx + offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // Score for vertical\n    // Scores are calculated for window lengths of 4\n    for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n        const aColumnOfSquaresArr = [];\n        for (let i = currColIdx; i < TOTALNUMOFSQUARES; i += TOTALNUMOFCOLUMNS) { // gets the stack of squares in the given column denoted by currColIdx\n            aColumnOfSquaresArr.push(newBoard[i]);\n        }\n        for (let i = 0; i <= TOTALNUMOFROWS - WINDOWLENGTH; i++) {\n            const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, player, opposingPlayer);\n        }\n\n    }\n\n    // Score for diagonal\n    // Scores are calculated for window lengths of 4\n\n    // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); currIdx >= 0; currIdx -= TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currIdx\n        for (let i = 0; currIdx + i * TOTALNUMOFCOLUMNS + i < TOTALNUMOFSQUARES; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currIdx + i * TOTALNUMOFCOLUMNS + i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currIdx = (TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2)) + TOTALNUMOFCOLUMNS - 1; currIdx < TOTALNUMOFSQUARES; currIdx += TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currIdx\n        for (let i = 0; currIdx - i * TOTALNUMOFCOLUMNS - i >= 0; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currIdx - i * TOTALNUMOFCOLUMNS - i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currIdx = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2); currIdx < TOTALNUMOFSQUARES; currIdx += TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currIdx\n        for (let i = 0; currIdx - i * TOTALNUMOFCOLUMNS + i >= 0; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currIdx - i * TOTALNUMOFCOLUMNS + i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // CONTINUE HERE AFTER DINNER\n\n    // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currRowIdx\n        for (let i = 0; currRowIdx - i * TOTALNUMOFCOLUMNS + i >= 0; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currRowIdx - i * TOTALNUMOFCOLUMNS + i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    return score;\n}\n\nfunction idxOfMaxOfArr(arr) {\n    let max = arr[0];\n    let maxIdx = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] > max) {\n            max = arr[i]\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n\nfunction minimax(board, depth, maximizingPlayer, minimizingPlayer) {\n    /**\n     * minimax algorithm to determine how the ai will make its move\n     * refer to the pseudocode on wikipedia\n     */\n\n    // get all the possible moves that the player can drop into\n    // this should be an array with the indices\n    const possibleMovesArr = [0,1,2,3,4,5,6].map(idx => findLegalSquare(board, idx)).filter(idx => idx !== -1);\n    const scoresForPossibleMovesArr = possibleMovesArr.map(idx => calculateScoreForMove(board, idx, maximizingPlayer, minimizingPlayer));\n    alert(scoresForPossibleMovesArr);\n    return possibleMovesArr[idxOfMaxOfArr(scoresForPossibleMovesArr)];\n}\n\nexport default minimax;"]},"metadata":{},"sourceType":"module"}