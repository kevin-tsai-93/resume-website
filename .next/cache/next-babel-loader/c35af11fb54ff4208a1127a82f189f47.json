{"ast":null,"code":"const TOTALNUMOFCOLUMNS = 7;\nconst TOTALNUMOFROWS = 6;\nconst TOTALNUMOFSQUARES = 42;\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n  /**\n   * Returns the row index of a legal square that can be filled given the board (2 dimensional row x col).\n   * Note the legal square will be within the same column as selectedColIdx.\n   * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n   */\n  const didNotFindLegalRowIdxWithinColumnIdx = -1;\n\n  for (let rowIdx = 0; rowIdx < board.length; rowIdx++) {\n    if (board[rowIdx][selectedColIdx] === null) {\n      return rowIdx;\n    }\n  }\n\n  return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, player, opposingPlayer) {\n  /**\n   * Returns the score for the given arr, assuming the length of the arr is 4\n   */\n  let score = 0;\n\n  if (arr.filter(val => val === player).length === 4) {\n    score += 100;\n  } else if (arr.filter(val => val === player).length === 3 && arr.filter(val => val === null).length === 1) {\n    score += 5;\n  } else if (arr.filter(val => val === player).length === 2 && arr.filter(val => val === null).length === 2) {\n    score += 2;\n  }\n\n  if (arr.filter(val => val === opposingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n    score -= 15;\n  }\n\n  return score;\n}\n\nfunction calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer) {\n  /**\n   * Returns the score for placing player's piece onto the board whose location is idx.\n   */\n  let score = 0;\n  const WINDOWLENGTH = 4;\n  const CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n  const newBoard = board.slice();\n  newBoard[idx] = player; // score for center piece (preference center location)\n\n  for (let i = CENTERCOLUMNIDX; i < TOTALNUMOFSQUARES; i += TOTALNUMOFCOLUMNS) {\n    if (newBoard[i] === player) {\n      score += 2;\n    }\n  } // Score for horizontal\n  // Scores are calculated for window lengths of 4\n\n\n  for (let currRowIdx = 0; currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n    for (let offset = 0; offset <= TOTALNUMOFCOLUMNS - WINDOWLENGTH; offset++) {\n      const horizontalFourAdjacentSquares = newBoard.slice(currRowIdx + offset, currRowIdx + offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Score for vertical\n  // Scores are calculated for window lengths of 4\n\n\n  for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n    const aColumnOfSquaresArr = [];\n\n    for (let i = currColIdx; i < TOTALNUMOFSQUARES; i += TOTALNUMOFCOLUMNS) {\n      // gets the stack of squares in the given column denoted by currColIdx\n      aColumnOfSquaresArr.push(newBoard[i]);\n    }\n\n    for (let i = 0; i <= TOTALNUMOFROWS - WINDOWLENGTH; i++) {\n      const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(i, i + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Score for diagonal\n  // Scores are calculated for window lengths of 4\n  // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (let currIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); currIdx >= 0; currIdx -= TOTALNUMOFCOLUMNS) {\n    const aDiagonalOfSquaresArr = []; // assemble the diagonal of squares arr for the given currIdx\n\n    for (let i = 0; currIdx + i * TOTALNUMOFCOLUMNS + i < TOTALNUMOFSQUARES; i++) {\n      aDiagonalOfSquaresArr.push(newBoard[currIdx + i * TOTALNUMOFCOLUMNS + i]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (let currIdx = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2) + TOTALNUMOFCOLUMNS - 1; currIdx < TOTALNUMOFSQUARES; currIdx += TOTALNUMOFCOLUMNS) {\n    const aDiagonalOfSquaresArr = []; // assemble the diagonal of squares arr for the given currIdx\n\n    for (let i = 0; currIdx - i * TOTALNUMOFCOLUMNS - i >= 0; i++) {\n      aDiagonalOfSquaresArr.push(newBoard[currIdx - i * TOTALNUMOFCOLUMNS - i]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (let currIdx = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2); currIdx < TOTALNUMOFSQUARES; currIdx += TOTALNUMOFCOLUMNS) {\n    const aDiagonalOfSquaresArr = []; // assemble the diagonal of squares arr for the given currIdx\n\n    for (let i = 0; currIdx - i * TOTALNUMOFCOLUMNS + i >= 0; i++) {\n      aDiagonalOfSquaresArr.push(newBoard[currIdx - i * TOTALNUMOFCOLUMNS + i]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // CONTINUE HERE AFTER DINNER\n  // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n    const aDiagonalOfSquaresArr = []; // assemble the diagonal of squares arr for the given currRowIdx\n\n    for (let i = 0; currRowIdx - i * TOTALNUMOFCOLUMNS + i >= 0; i++) {\n      aDiagonalOfSquaresArr.push(newBoard[currRowIdx - i * TOTALNUMOFCOLUMNS + i]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n    }\n  }\n\n  return score;\n}\n\nfunction idxOfMaxOfArr(arr) {\n  let max = arr[0];\n  let maxIdx = 0;\n\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIdx = i;\n    }\n  }\n\n  return maxIdx;\n}\n\nfunction minimax(board, depth, maximizingPlayer, minimizingPlayer) {\n  /**\n   * minimax algorithm to determine how the ai will make its move\n   * refer to the pseudocode on wikipedia\n   */\n  // get all the possible moves that the player can drop onto the board\n  // will have 2 arrays: column index array and row index array\n  // refer to the note below about the relationship between these two arrays\n  const columnIndicesOfBoard = []; // this will look like [0,1,2,3,4,5,6]\n\n  for (let i = 0; i < TOTALNUMOFCOLUMNS; i++) {\n    columnIndicesOfBoard.push(i);\n  } // note that possibleRowIndicesToPlacePieceOntoBoard is relative to columnIndicesOfBoard\n  // i.e. columnIndicesOfBoard = [0,1,2,3,4,5,6]\n  // i.e. possibleRowIndicesToPlacePieceOntoBoard = [3,3,4,2,1,2,1]\n  // this means board[3][0]... board[3][1]... board[4][2]... board[2][3]... board[1][4]... etc are pieces that can be placed onto the board\n\n\n  const possibleRowIndicesToPlacePieceOntoBoard = columnIndicesOfBoard.map(colIdx => findLegalRowIdxWithinColumn(board, colIdx)); // note that possibleRowIndicesToPlacePieceOntoBoard might have -1 values\n\n  let maxScore = null;\n  let optimalRowIdx;\n  let optimalColIdx;\n\n  for (let i = 0; i < columnIndicesOfBoard.length; i++) {\n    if (possibleRowIndicesToPlacePieceOntoBoard[i] !== -1) {\n      let rowIdx = possibleRowIndicesToPlacePieceOntoBoard[i];\n      let colIdx = columnIndicesOfBoard[i];\n      let score = calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer);\n\n      if (maxScore === null || score >= maxScore) {\n        maxScore = score;\n        optimalRowIdx = rowIdx;\n        optimalColIdx = colIdx;\n      }\n    }\n  }\n\n  alert(scoresForPossibleMovesArr);\n  return possibleMovesArr[idxOfMaxOfArr(scoresForPossibleMovesArr)];\n}\n\nexport default minimax;","map":{"version":3,"sources":["/Users/kevintsai/Desktop/resume_website/components/portfolio/connect4/minimax.js"],"names":["TOTALNUMOFCOLUMNS","TOTALNUMOFROWS","TOTALNUMOFSQUARES","findLegalRowIdxWithinColumn","board","selectedColIdx","didNotFindLegalRowIdxWithinColumnIdx","rowIdx","length","calculateScoreForThese4Squares","arr","player","opposingPlayer","score","filter","val","calculateScoreForMove","colIdx","maximizingPlayer","minimizingPlayer","WINDOWLENGTH","CENTERCOLUMNIDX","Math","floor","newBoard","slice","idx","i","currRowIdx","offset","horizontalFourAdjacentSquares","currColIdx","aColumnOfSquaresArr","push","verticalFourAdjacentSquares","currIdx","aDiagonalOfSquaresArr","diagonalFourAdjacentSquares","idxOfMaxOfArr","max","maxIdx","minimax","depth","columnIndicesOfBoard","possibleRowIndicesToPlacePieceOntoBoard","map","maxScore","optimalRowIdx","optimalColIdx","alert","scoresForPossibleMovesArr","possibleMovesArr"],"mappings":"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","sourcesContent":["const TOTALNUMOFCOLUMNS = 7;\nconst TOTALNUMOFROWS = 6;\nconst TOTALNUMOFSQUARES = 42;\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n    /**\n     * Returns the row index of a legal square that can be filled given the board (2 dimensional row x col).\n     * Note the legal square will be within the same column as selectedColIdx.\n     * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n     */\n    const didNotFindLegalRowIdxWithinColumnIdx = -1;\n    for (let rowIdx = 0; rowIdx < board.length; rowIdx++) {\n        if (board[rowIdx][selectedColIdx] === null) {\n            return rowIdx;\n        }\n    }\n    return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, player, opposingPlayer) {\n    /**\n     * Returns the score for the given arr, assuming the length of the arr is 4\n     */\n\n    let score = 0;\n\n    if (arr.filter(val => val === player).length === 4) {\n        score += 100;\n    } else if (arr.filter(val => val === player).length === 3 && arr.filter(val => val === null).length === 1) {\n        score += 5;\n    } else if (arr.filter(val => val === player).length === 2 && arr.filter(val => val === null).length === 2) {\n        score += 2;\n    }\n\n    if (arr.filter(val => val === opposingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score -= 15;\n    }\n\n    return score;\n}\n\nfunction calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer) {\n    /**\n     * Returns the score for placing player's piece onto the board whose location is idx.\n     */\n\n    let score = 0;\n    const WINDOWLENGTH = 4;\n    const CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n    const newBoard = board.slice();\n    newBoard[idx] = player;\n\n    // score for center piece (preference center location)\n    for (let i = CENTERCOLUMNIDX; i < TOTALNUMOFSQUARES; i += TOTALNUMOFCOLUMNS) {\n        if (newBoard[i] === player) {\n            score += 2;\n        }\n    }\n\n\n    // Score for horizontal\n    // Scores are calculated for window lengths of 4\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n        for (let offset = 0; offset <= TOTALNUMOFCOLUMNS - WINDOWLENGTH; offset++) {\n            const horizontalFourAdjacentSquares = newBoard.slice(currRowIdx + offset, currRowIdx + offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // Score for vertical\n    // Scores are calculated for window lengths of 4\n    for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n        const aColumnOfSquaresArr = [];\n        for (let i = currColIdx; i < TOTALNUMOFSQUARES; i += TOTALNUMOFCOLUMNS) { // gets the stack of squares in the given column denoted by currColIdx\n            aColumnOfSquaresArr.push(newBoard[i]);\n        }\n        for (let i = 0; i <= TOTALNUMOFROWS - WINDOWLENGTH; i++) {\n            const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, player, opposingPlayer);\n        }\n\n    }\n\n    // Score for diagonal\n    // Scores are calculated for window lengths of 4\n\n    // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); currIdx >= 0; currIdx -= TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currIdx\n        for (let i = 0; currIdx + i * TOTALNUMOFCOLUMNS + i < TOTALNUMOFSQUARES; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currIdx + i * TOTALNUMOFCOLUMNS + i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currIdx = (TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2)) + TOTALNUMOFCOLUMNS - 1; currIdx < TOTALNUMOFSQUARES; currIdx += TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currIdx\n        for (let i = 0; currIdx - i * TOTALNUMOFCOLUMNS - i >= 0; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currIdx - i * TOTALNUMOFCOLUMNS - i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currIdx = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2); currIdx < TOTALNUMOFSQUARES; currIdx += TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currIdx\n        for (let i = 0; currIdx - i * TOTALNUMOFCOLUMNS + i >= 0; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currIdx - i * TOTALNUMOFCOLUMNS + i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // CONTINUE HERE AFTER DINNER\n\n    // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currRowIdx\n        for (let i = 0; currRowIdx - i * TOTALNUMOFCOLUMNS + i >= 0; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currRowIdx - i * TOTALNUMOFCOLUMNS + i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    return score;\n}\n\nfunction idxOfMaxOfArr(arr) {\n    let max = arr[0];\n    let maxIdx = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] > max) {\n            max = arr[i]\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n\nfunction minimax(board, depth, maximizingPlayer, minimizingPlayer) {\n    /**\n     * minimax algorithm to determine how the ai will make its move\n     * refer to the pseudocode on wikipedia\n     */\n\n    // get all the possible moves that the player can drop onto the board\n    // will have 2 arrays: column index array and row index array\n    // refer to the note below about the relationship between these two arrays\n    const columnIndicesOfBoard = []; // this will look like [0,1,2,3,4,5,6]\n    for (let i = 0; i < TOTALNUMOFCOLUMNS; i++) {\n        columnIndicesOfBoard.push(i);\n    }\n    // note that possibleRowIndicesToPlacePieceOntoBoard is relative to columnIndicesOfBoard\n    // i.e. columnIndicesOfBoard = [0,1,2,3,4,5,6]\n    // i.e. possibleRowIndicesToPlacePieceOntoBoard = [3,3,4,2,1,2,1]\n    // this means board[3][0]... board[3][1]... board[4][2]... board[2][3]... board[1][4]... etc are pieces that can be placed onto the board\n    const possibleRowIndicesToPlacePieceOntoBoard = columnIndicesOfBoard.map(colIdx => findLegalRowIdxWithinColumn(board, colIdx)); // note that possibleRowIndicesToPlacePieceOntoBoard might have -1 values\n    \n    let maxScore = null;\n    let optimalRowIdx;\n    let optimalColIdx;\n\n    for (let i = 0; i < columnIndicesOfBoard.length; i++) {\n        if (possibleRowIndicesToPlacePieceOntoBoard[i] !== -1) {\n            let rowIdx = possibleRowIndicesToPlacePieceOntoBoard[i];\n            let colIdx = columnIndicesOfBoard[i];\n            let score = calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer);\n            if (maxScore === null || score >= maxScore) {\n                maxScore = score;\n                optimalRowIdx = rowIdx;\n                optimalColIdx = colIdx;\n            }\n        }\n    }\n    alert(scoresForPossibleMovesArr);\n    return possibleMovesArr[idxOfMaxOfArr(scoresForPossibleMovesArr)];\n}\n\nexport default minimax;"]},"metadata":{},"sourceType":"module"}