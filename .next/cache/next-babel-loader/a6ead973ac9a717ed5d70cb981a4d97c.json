{"ast":null,"code":"var TOTALNUMOFCOLUMNS = 7;\nvar TOTALNUMOFROWS = 6;\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n  /**\n   * Returns the row index of a legal square that can be filled given the board (2 dimensional row x col).\n   * Note the legal square will be within the same column as selectedColIdx.\n   * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n   */\n  var didNotFindLegalRowIdxWithinColumnIdx = -1;\n\n  for (var rowIdx = 0; rowIdx < board.length; rowIdx++) {\n    if (board[rowIdx][selectedColIdx] === null) {\n      return rowIdx;\n    }\n  }\n\n  return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, maximizingPlayer, minimizingPlayer) {\n  /**\n   * Returns the score for the given arr, assuming the length of the arr is 4\n   */\n  var score = 0;\n\n  if (arr.filter(function (val) {\n    return val === maximizingPlayer;\n  }).length === 4) {\n    score += 100;\n  } else if (arr.filter(function (val) {\n    return val === maximizingPlayer;\n  }).length === 3 && arr.filter(function (val) {\n    return val === null;\n  }).length === 1) {\n    score += 5;\n  } else if (arr.filter(function (val) {\n    return val === maximizingPlayer;\n  }).length === 2 && arr.filter(function (val) {\n    return val === null;\n  }).length === 2) {\n    score += 2;\n  }\n\n  if (arr.filter(function (val) {\n    return val === minimizingPlayer;\n  }).length === 3 && arr.filter(function (val) {\n    return val === null;\n  }).length === 1) {\n    score -= 15;\n  }\n\n  return score;\n}\n\nfunction calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer) {\n  /**\n   * Returns the score for placing maximizingPlayer's piece onto the board whose location is rowIdx and colIdx.\n   */\n  var score = 0;\n  var WINDOWLENGTH = 4;\n  var CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n  var newBoard = board.slice();\n  newBoard[rowIdx][colIdx] = maximizingPlayer; // score for center piece (preference center location)\n\n  for (var currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    if (newBoard[currRowIdx][CENTERCOLUMNIDX] === maximizingPlayer) {\n      score += 2;\n    }\n  } // Score for horizontal\n  // Scores are calculated for window lengths of 4\n\n\n  for (var _currRowIdx = 0; _currRowIdx < TOTALNUMOFSQUARES; _currRowIdx += TOTALNUMOFCOLUMNS) {\n    for (var offset = 0; offset <= TOTALNUMOFCOLUMNS - WINDOWLENGTH; offset++) {\n      var horizontalFourAdjacentSquares = newBoard.slice(_currRowIdx + offset, _currRowIdx + offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Score for vertical\n  // Scores are calculated for window lengths of 4\n\n\n  for (var currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n    var aColumnOfSquaresArr = [];\n\n    for (var i = currColIdx; i < TOTALNUMOFSQUARES; i += TOTALNUMOFCOLUMNS) {\n      // gets the stack of squares in the given column denoted by currColIdx\n      aColumnOfSquaresArr.push(newBoard[i]);\n    }\n\n    for (var _i = 0; _i <= TOTALNUMOFROWS - WINDOWLENGTH; _i++) {\n      var verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(_i, _i + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Score for diagonal\n  // Scores are calculated for window lengths of 4\n  // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var currIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); currIdx >= 0; currIdx -= TOTALNUMOFCOLUMNS) {\n    var aDiagonalOfSquaresArr = []; // assemble the diagonal of squares arr for the given currIdx\n\n    for (var _i2 = 0; currIdx + _i2 * TOTALNUMOFCOLUMNS + _i2 < TOTALNUMOFSQUARES; _i2++) {\n      aDiagonalOfSquaresArr.push(newBoard[currIdx + _i2 * TOTALNUMOFCOLUMNS + _i2]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (var _i3 = 0; _i3 <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; _i3++) {\n      var diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(_i3, _i3 + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currIdx = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2) + TOTALNUMOFCOLUMNS - 1; _currIdx < TOTALNUMOFSQUARES; _currIdx += TOTALNUMOFCOLUMNS) {\n    var _aDiagonalOfSquaresArr = []; // assemble the diagonal of squares arr for the given currIdx\n\n    for (var _i4 = 0; _currIdx - _i4 * TOTALNUMOFCOLUMNS - _i4 >= 0; _i4++) {\n      _aDiagonalOfSquaresArr.push(newBoard[_currIdx - _i4 * TOTALNUMOFCOLUMNS - _i4]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (var _i5 = 0; _i5 <= _aDiagonalOfSquaresArr.length - WINDOWLENGTH; _i5++) {\n      var _diagonalFourAdjacentSquares = _aDiagonalOfSquaresArr.slice(_i5, _i5 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares, player, opposingPlayer);\n    }\n  } // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var _currIdx2 = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2); _currIdx2 < TOTALNUMOFSQUARES; _currIdx2 += TOTALNUMOFCOLUMNS) {\n    var _aDiagonalOfSquaresArr2 = []; // assemble the diagonal of squares arr for the given currIdx\n\n    for (var _i6 = 0; _currIdx2 - _i6 * TOTALNUMOFCOLUMNS + _i6 >= 0; _i6++) {\n      _aDiagonalOfSquaresArr2.push(newBoard[_currIdx2 - _i6 * TOTALNUMOFCOLUMNS + _i6]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (var _i7 = 0; _i7 <= _aDiagonalOfSquaresArr2.length - WINDOWLENGTH; _i7++) {\n      var _diagonalFourAdjacentSquares2 = _aDiagonalOfSquaresArr2.slice(_i7, _i7 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares2, player, opposingPlayer);\n    }\n  } // CONTINUE HERE AFTER DINNER\n  // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx2 = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); _currRowIdx2 < TOTALNUMOFSQUARES; _currRowIdx2 += TOTALNUMOFCOLUMNS) {\n    var _aDiagonalOfSquaresArr3 = []; // assemble the diagonal of squares arr for the given currRowIdx\n\n    for (var _i8 = 0; _currRowIdx2 - _i8 * TOTALNUMOFCOLUMNS + _i8 >= 0; _i8++) {\n      _aDiagonalOfSquaresArr3.push(newBoard[_currRowIdx2 - _i8 * TOTALNUMOFCOLUMNS + _i8]);\n    } // slice the diagonal squares array with window lengths of 4 and calculate score\n\n\n    for (var _i9 = 0; _i9 <= _aDiagonalOfSquaresArr3.length - WINDOWLENGTH; _i9++) {\n      var _diagonalFourAdjacentSquares3 = _aDiagonalOfSquaresArr3.slice(_i9, _i9 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares3, player, opposingPlayer);\n    }\n  }\n\n  return score;\n}\n\nfunction minimax(board, depth, maximizingPlayer, minimizingPlayer) {\n  /**\n   * minimax algorithm to determine how and where the ai will make its move\n   * refer to the pseudocode on wikipedia\n   * it will return the optimal rowIdx and colIdx, the location to place the piece onto the board\n   * return value looks like [optimalRowIdx, optimalColIdx]\n   * \n   * board is a row x col array\n   * depth tells you how far down the tree you will traverse to find the calculated score\n   * maximizingPlayer is the player that is trying to win... in this case the AI = \"ai\"\n   * minimizingPlayer is the player that is trying to prevent the maximizingPlayer from winning... in this case HUMAN = \"you\"\n   */\n  // get all the possible moves that the player can drop onto the board\n  // will have 2 arrays: column index array and row index array\n  // refer to the note below about the relationship between these two arrays\n  var columnIndicesOfBoard = []; // this will look like [0,1,2,3,4,5,6]\n\n  for (var i = 0; i < TOTALNUMOFCOLUMNS; i++) {\n    columnIndicesOfBoard.push(i);\n  } // note that possibleRowIndicesToPlacePieceOntoBoard is relative to columnIndicesOfBoard\n  // i.e. columnIndicesOfBoard = [0,1,2,3,4,5,6]\n  // i.e. possibleRowIndicesToPlacePieceOntoBoard = [3,3,4,2,1,2,1]\n  // this means board[3][0]... board[3][1]... board[4][2]... board[2][3]... board[1][4]... etc are pieces that can be placed onto the board\n\n\n  var possibleRowIndicesToPlacePieceOntoBoard = columnIndicesOfBoard.map(function (colIdx) {\n    return findLegalRowIdxWithinColumn(board, colIdx);\n  }); // note that possibleRowIndicesToPlacePieceOntoBoard might have -1 values\n\n  var maxScore = null;\n  var optimalRowIdx;\n  var optimalColIdx;\n  var scoresForPossibleMovesArr = []; // delete this later\n\n  for (var _i10 = 0; _i10 < columnIndicesOfBoard.length; _i10++) {\n    if (possibleRowIndicesToPlacePieceOntoBoard[_i10] !== -1) {\n      var rowIdx = possibleRowIndicesToPlacePieceOntoBoard[_i10];\n      var colIdx = columnIndicesOfBoard[_i10];\n      var calculatedScore = calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer);\n      scoresForPossibleMovesArr.push(calculatedScore); // delete this later\n\n      if (maxScore === null || calculatedScore >= maxScore) {\n        maxScore = calculatedScore;\n        optimalRowIdx = rowIdx;\n        optimalColIdx = colIdx;\n      }\n    }\n  }\n\n  alert(scoresForPossibleMovesArr);\n  return [optimalRowIdx, optimalColIdx];\n}\n\nexport default minimax;","map":{"version":3,"sources":["/Users/kevintsai/Desktop/resume_website/components/portfolio/connect4/minimax.js"],"names":["TOTALNUMOFCOLUMNS","TOTALNUMOFROWS","findLegalRowIdxWithinColumn","board","selectedColIdx","didNotFindLegalRowIdxWithinColumnIdx","rowIdx","length","calculateScoreForThese4Squares","arr","maximizingPlayer","minimizingPlayer","score","filter","val","calculateScoreForMove","colIdx","WINDOWLENGTH","CENTERCOLUMNIDX","Math","floor","newBoard","slice","currRowIdx","TOTALNUMOFSQUARES","offset","horizontalFourAdjacentSquares","player","opposingPlayer","currColIdx","aColumnOfSquaresArr","i","push","verticalFourAdjacentSquares","currIdx","aDiagonalOfSquaresArr","diagonalFourAdjacentSquares","minimax","depth","columnIndicesOfBoard","possibleRowIndicesToPlacePieceOntoBoard","map","maxScore","optimalRowIdx","optimalColIdx","scoresForPossibleMovesArr","calculatedScore","alert"],"mappings":"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","sourcesContent":["const TOTALNUMOFCOLUMNS = 7;\nconst TOTALNUMOFROWS = 6;\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n    /**\n     * Returns the row index of a legal square that can be filled given the board (2 dimensional row x col).\n     * Note the legal square will be within the same column as selectedColIdx.\n     * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n     */\n    const didNotFindLegalRowIdxWithinColumnIdx = -1;\n    for (let rowIdx = 0; rowIdx < board.length; rowIdx++) {\n        if (board[rowIdx][selectedColIdx] === null) {\n            return rowIdx;\n        }\n    }\n    return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, maximizingPlayer, minimizingPlayer) {\n    /**\n     * Returns the score for the given arr, assuming the length of the arr is 4\n     */\n\n    let score = 0;\n\n    if (arr.filter(val => val === maximizingPlayer).length === 4) {\n        score += 100;\n    } else if (arr.filter(val => val === maximizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score += 5;\n    } else if (arr.filter(val => val === maximizingPlayer).length === 2 && arr.filter(val => val === null).length === 2) {\n        score += 2;\n    }\n\n    if (arr.filter(val => val === minimizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score -= 15;\n    }\n\n    return score;\n}\n\nfunction calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer) {\n    /**\n     * Returns the score for placing maximizingPlayer's piece onto the board whose location is rowIdx and colIdx.\n     */\n\n    let score = 0;\n    const WINDOWLENGTH = 4;\n    const CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n    const newBoard = board.slice();\n    newBoard[rowIdx][colIdx] = maximizingPlayer;\n\n    // score for center piece (preference center location)\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        if (newBoard[currRowIdx][CENTERCOLUMNIDX] === maximizingPlayer) {\n            score += 2;\n        }\n    }\n\n\n    // Score for horizontal\n    // Scores are calculated for window lengths of 4\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n        for (let offset = 0; offset <= TOTALNUMOFCOLUMNS - WINDOWLENGTH; offset++) {\n            const horizontalFourAdjacentSquares = newBoard.slice(currRowIdx + offset, currRowIdx + offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // Score for vertical\n    // Scores are calculated for window lengths of 4\n    for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n        const aColumnOfSquaresArr = [];\n        for (let i = currColIdx; i < TOTALNUMOFSQUARES; i += TOTALNUMOFCOLUMNS) { // gets the stack of squares in the given column denoted by currColIdx\n            aColumnOfSquaresArr.push(newBoard[i]);\n        }\n        for (let i = 0; i <= TOTALNUMOFROWS - WINDOWLENGTH; i++) {\n            const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, player, opposingPlayer);\n        }\n\n    }\n\n    // Score for diagonal\n    // Scores are calculated for window lengths of 4\n\n    // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); currIdx >= 0; currIdx -= TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currIdx\n        for (let i = 0; currIdx + i * TOTALNUMOFCOLUMNS + i < TOTALNUMOFSQUARES; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currIdx + i * TOTALNUMOFCOLUMNS + i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currIdx = (TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2)) + TOTALNUMOFCOLUMNS - 1; currIdx < TOTALNUMOFSQUARES; currIdx += TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currIdx\n        for (let i = 0; currIdx - i * TOTALNUMOFCOLUMNS - i >= 0; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currIdx - i * TOTALNUMOFCOLUMNS - i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currIdx = TOTALNUMOFCOLUMNS * Math.floor(TOTALNUMOFROWS / 2); currIdx < TOTALNUMOFSQUARES; currIdx += TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currIdx\n        for (let i = 0; currIdx - i * TOTALNUMOFCOLUMNS + i >= 0; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currIdx - i * TOTALNUMOFCOLUMNS + i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    // CONTINUE HERE AFTER DINNER\n\n    // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = TOTALNUMOFCOLUMNS * (Math.floor(TOTALNUMOFROWS / 2) - 1); currRowIdx < TOTALNUMOFSQUARES; currRowIdx += TOTALNUMOFCOLUMNS) {\n        const aDiagonalOfSquaresArr = [];\n        // assemble the diagonal of squares arr for the given currRowIdx\n        for (let i = 0; currRowIdx - i * TOTALNUMOFCOLUMNS + i >= 0; i++) {\n            aDiagonalOfSquaresArr.push(newBoard[currRowIdx - i * TOTALNUMOFCOLUMNS + i]);\n        }\n        // slice the diagonal squares array with window lengths of 4 and calculate score\n        for (let i = 0; i <= aDiagonalOfSquaresArr.length - WINDOWLENGTH; i++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(i, i + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, player, opposingPlayer);\n        }\n    }\n\n    return score;\n}\n\nfunction minimax(board, depth, maximizingPlayer, minimizingPlayer) {\n    /**\n     * minimax algorithm to determine how and where the ai will make its move\n     * refer to the pseudocode on wikipedia\n     * it will return the optimal rowIdx and colIdx, the location to place the piece onto the board\n     * return value looks like [optimalRowIdx, optimalColIdx]\n     * \n     * board is a row x col array\n     * depth tells you how far down the tree you will traverse to find the calculated score\n     * maximizingPlayer is the player that is trying to win... in this case the AI = \"ai\"\n     * minimizingPlayer is the player that is trying to prevent the maximizingPlayer from winning... in this case HUMAN = \"you\"\n     */\n\n    // get all the possible moves that the player can drop onto the board\n    // will have 2 arrays: column index array and row index array\n    // refer to the note below about the relationship between these two arrays\n    const columnIndicesOfBoard = []; // this will look like [0,1,2,3,4,5,6]\n    for (let i = 0; i < TOTALNUMOFCOLUMNS; i++) {\n        columnIndicesOfBoard.push(i);\n    }\n    // note that possibleRowIndicesToPlacePieceOntoBoard is relative to columnIndicesOfBoard\n    // i.e. columnIndicesOfBoard = [0,1,2,3,4,5,6]\n    // i.e. possibleRowIndicesToPlacePieceOntoBoard = [3,3,4,2,1,2,1]\n    // this means board[3][0]... board[3][1]... board[4][2]... board[2][3]... board[1][4]... etc are pieces that can be placed onto the board\n    const possibleRowIndicesToPlacePieceOntoBoard = columnIndicesOfBoard.map(colIdx => findLegalRowIdxWithinColumn(board, colIdx)); // note that possibleRowIndicesToPlacePieceOntoBoard might have -1 values\n    \n    let maxScore = null;\n    let optimalRowIdx;\n    let optimalColIdx;\n\n    const scoresForPossibleMovesArr = []; // delete this later\n\n    for (let i = 0; i < columnIndicesOfBoard.length; i++) {\n        if (possibleRowIndicesToPlacePieceOntoBoard[i] !== -1) {\n            let rowIdx = possibleRowIndicesToPlacePieceOntoBoard[i];\n            let colIdx = columnIndicesOfBoard[i];\n            let calculatedScore = calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer);\n            scoresForPossibleMovesArr.push(calculatedScore); // delete this later\n            if (maxScore === null || calculatedScore >= maxScore) {\n                maxScore = calculatedScore;\n                optimalRowIdx = rowIdx;\n                optimalColIdx = colIdx;\n            }\n        }\n    }\n    alert(scoresForPossibleMovesArr);\n    return [optimalRowIdx, optimalColIdx];\n}\n\nexport default minimax;"]},"metadata":{},"sourceType":"module"}