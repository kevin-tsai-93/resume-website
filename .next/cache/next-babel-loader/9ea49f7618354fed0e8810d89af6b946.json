{"ast":null,"code":"import deepCopy2DArray from './deepCopy2DArray';\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n  /**\n   * Returns the row index of a legal square that can be filled given the board (2 dimensional row x col).\n   * Note the legal square will be within the same column as selectedColIdx.\n   * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n   */\n  const didNotFindLegalRowIdxWithinColumnIdx = -1;\n\n  for (let rowIdx = 0; rowIdx < board.length; rowIdx++) {\n    if (board[rowIdx][selectedColIdx] === null) {\n      return rowIdx;\n    }\n  }\n\n  return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, maximizingPlayer, minimizingPlayer) {\n  /**\n   * Returns the score for the given arr, assuming the length of the arr is 4\n   */\n  let score = 0;\n\n  if (arr.filter(val => val === maximizingPlayer).length === 4) {\n    score += 100;\n  } else if (arr.filter(val => val === maximizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n    score += 5;\n  } else if (arr.filter(val => val === maximizingPlayer).length === 2 && arr.filter(val => val === null).length === 2) {\n    score += 2;\n  }\n\n  if (arr.filter(val => val === minimizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n    score -= 15;\n  }\n\n  return score;\n}\n\nfunction calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer) {\n  /**\n   * Returns the score for placing maximizingPlayer's piece onto the board whose location is rowIdx and colIdx.\n   */\n  let score = 0;\n  const TOTALNUMOFROWS = board.length;\n  const TOTALNUMOFCOLUMNS = board[0].length;\n  const WINDOWLENGTH = 4;\n  const CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n  const newBoard = deepCopy2DArray(board);\n  newBoard[rowIdx][colIdx] = maximizingPlayer; // score for center piece (preference center location)\n\n  for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    if (newBoard[currRowIdx][CENTERCOLUMNIDX] === maximizingPlayer) {\n      score += 2;\n    }\n  } // Score for horizontal\n  // Scores are calculated for window lengths of 4\n\n\n  for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFCOLUMNS; offset++) {\n      const horizontalFourAdjacentSquares = newBoard[currRowIdx].slice(offset, offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Score for vertical\n  // Scores are calculated for window lengths of 4\n\n\n  for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n    const aColumnOfSquaresArr = [];\n\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n      aColumnOfSquaresArr.push(newBoard[currRowIdx][currColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFROWS; offset++) {\n      const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Score for diagonal\n  // Scores are calculated for window lengths of 4\n  // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n    const aDiagonalOfSquaresArr = [];\n\n    for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n      aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    const aDiagonalOfSquaresArr = [];\n\n    for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx >= 0 && runningColIdx > 0; runningRowIdx--, runningColIdx--) {\n      aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    const aDiagonalOfSquaresArr = [];\n\n    for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx >= 0 && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx--, runningColIdx++) {\n      aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n    const aDiagonalOfSquaresArr = [];\n\n    for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx < TOTALNUMOFROWS && runningColIdx > 0; runningRowIdx++, runningColIdx--) {\n      aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  }\n\n  return score;\n}\n\nfunction minimax(board, depth, maximizingPlayer, minimizingPlayer) {\n  /**\n   * minimax algorithm to determine how and where the ai will make its move\n   * refer to the pseudocode on wikipedia\n   * it will return the optimal rowIdx and colIdx, the location to place the piece onto the board\n   * return value looks like [optimalRowIdx, optimalColIdx]\n   * \n   * board is a row x col array\n   * depth tells you how far down the tree you will traverse to find the calculated score\n   * maximizingPlayer is the player that is trying to win... in this case the AI = \"ai\"\n   * minimizingPlayer is the player that is trying to prevent the maximizingPlayer from winning... in this case HUMAN = \"you\"\n   */\n  const TOTALNUMOFROWS = board.length; // might not need this hear\n\n  const TOTALNUMOFCOLUMNS = board[0].length; // get all the possible moves that the player can drop onto the board\n  // will have 2 arrays: column index array and row index array\n  // refer to the note below about the relationship between these two arrays\n\n  const columnIndicesOfBoard = []; // this will look like [0,1,2,3,4,5,6]\n\n  for (let i = 0; i < TOTALNUMOFCOLUMNS; i++) {\n    columnIndicesOfBoard.push(i);\n  } // note that possibleRowIndicesToPlacePieceOntoBoard is relative to columnIndicesOfBoard\n  // i.e. columnIndicesOfBoard = [0,1,2,3,4,5,6]\n  // i.e. possibleRowIndicesToPlacePieceOntoBoard = [3,3,4,2,1,2,1]\n  // this means board[3][0]... board[3][1]... board[4][2]... board[2][3]... board[1][4]... etc are pieces that can be placed onto the board\n\n\n  const possibleRowIndicesToPlacePieceOntoBoard = columnIndicesOfBoard.map(colIdx => findLegalRowIdxWithinColumn(board, colIdx)); // note that possibleRowIndicesToPlacePieceOntoBoard might have -1 values\n\n  let maxScore = null;\n  let optimalRowIdx;\n  let optimalColIdx;\n  const scoresForPossibleMovesArr = []; // delete this later\n\n  for (let i = 0; i < columnIndicesOfBoard.length; i++) {\n    if (possibleRowIndicesToPlacePieceOntoBoard[i] !== -1) {\n      let rowIdx = possibleRowIndicesToPlacePieceOntoBoard[i];\n      let colIdx = columnIndicesOfBoard[i];\n      let calculatedScore = calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer);\n      scoresForPossibleMovesArr.push(calculatedScore); // delete this later\n\n      if (maxScore === null || calculatedScore >= maxScore) {\n        maxScore = calculatedScore;\n        optimalRowIdx = rowIdx;\n        optimalColIdx = colIdx;\n      }\n    }\n  }\n\n  alert(scoresForPossibleMovesArr); // delete this later\n\n  return [optimalRowIdx, optimalColIdx];\n}\n\nexport default minimax;","map":{"version":3,"sources":["/Users/kevintsai/Desktop/resume_website/components/portfolio/connect4/minimax.js"],"names":["deepCopy2DArray","findLegalRowIdxWithinColumn","board","selectedColIdx","didNotFindLegalRowIdxWithinColumnIdx","rowIdx","length","calculateScoreForThese4Squares","arr","maximizingPlayer","minimizingPlayer","score","filter","val","calculateScoreForMove","colIdx","TOTALNUMOFROWS","TOTALNUMOFCOLUMNS","WINDOWLENGTH","CENTERCOLUMNIDX","Math","floor","newBoard","currRowIdx","offset","horizontalFourAdjacentSquares","slice","currColIdx","aColumnOfSquaresArr","push","verticalFourAdjacentSquares","aDiagonalOfSquaresArr","runningRowIdx","runningColIdx","diagonalFourAdjacentSquares","minimax","depth","columnIndicesOfBoard","i","possibleRowIndicesToPlacePieceOntoBoard","map","maxScore","optimalRowIdx","optimalColIdx","scoresForPossibleMovesArr","calculatedScore","alert"],"mappings":"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","sourcesContent":["import deepCopy2DArray from './deepCopy2DArray';\n\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n    /**\n     * Returns the row index of a legal square that can be filled given the board (2 dimensional row x col).\n     * Note the legal square will be within the same column as selectedColIdx.\n     * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n     */\n    const didNotFindLegalRowIdxWithinColumnIdx = -1;\n    for (let rowIdx = 0; rowIdx < board.length; rowIdx++) {\n        if (board[rowIdx][selectedColIdx] === null) {\n            return rowIdx;\n        }\n    }\n    return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, maximizingPlayer, minimizingPlayer) {\n    /**\n     * Returns the score for the given arr, assuming the length of the arr is 4\n     */\n\n    let score = 0;\n\n    if (arr.filter(val => val === maximizingPlayer).length === 4) {\n        score += 100;\n    } else if (arr.filter(val => val === maximizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score += 5;\n    } else if (arr.filter(val => val === maximizingPlayer).length === 2 && arr.filter(val => val === null).length === 2) {\n        score += 2;\n    }\n\n    if (arr.filter(val => val === minimizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score -= 15;\n    }\n\n    return score;\n}\n\nfunction calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer) {\n    /**\n     * Returns the score for placing maximizingPlayer's piece onto the board whose location is rowIdx and colIdx.\n     */\n\n    let score = 0;\n\n    const TOTALNUMOFROWS = board.length;\n    const TOTALNUMOFCOLUMNS = board[0].length;\n    const WINDOWLENGTH = 4;\n    const CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n\n    const newBoard = deepCopy2DArray(board);\n    newBoard[rowIdx][colIdx] = maximizingPlayer;\n\n    // score for center piece (preference center location)\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        if (newBoard[currRowIdx][CENTERCOLUMNIDX] === maximizingPlayer) {\n            score += 2;\n        }\n    }\n\n\n    // Score for horizontal\n    // Scores are calculated for window lengths of 4\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFCOLUMNS; offset++) {\n            const horizontalFourAdjacentSquares = newBoard[currRowIdx].slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Score for vertical\n    // Scores are calculated for window lengths of 4\n    for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n        const aColumnOfSquaresArr = [];\n        for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n            aColumnOfSquaresArr.push(newBoard[currRowIdx][currColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFROWS; offset++) {\n            const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Score for diagonal\n    // Scores are calculated for window lengths of 4\n\n    // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n            aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx >= 0 && runningColIdx > 0; runningRowIdx--, runningColIdx--) {\n            aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx >= 0 && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx--, runningColIdx++) {\n            aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx < TOTALNUMOFROWS && runningColIdx > 0; runningRowIdx++, runningColIdx--) {\n            aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    return score;\n}\n\nfunction minimax(board, depth, maximizingPlayer, minimizingPlayer) {\n    /**\n     * minimax algorithm to determine how and where the ai will make its move\n     * refer to the pseudocode on wikipedia\n     * it will return the optimal rowIdx and colIdx, the location to place the piece onto the board\n     * return value looks like [optimalRowIdx, optimalColIdx]\n     * \n     * board is a row x col array\n     * depth tells you how far down the tree you will traverse to find the calculated score\n     * maximizingPlayer is the player that is trying to win... in this case the AI = \"ai\"\n     * minimizingPlayer is the player that is trying to prevent the maximizingPlayer from winning... in this case HUMAN = \"you\"\n     */\n\n    const TOTALNUMOFROWS = board.length; // might not need this hear\n    const TOTALNUMOFCOLUMNS = board[0].length;\n\n    // get all the possible moves that the player can drop onto the board\n    // will have 2 arrays: column index array and row index array\n    // refer to the note below about the relationship between these two arrays\n    const columnIndicesOfBoard = []; // this will look like [0,1,2,3,4,5,6]\n    for (let i = 0; i < TOTALNUMOFCOLUMNS; i++) {\n        columnIndicesOfBoard.push(i);\n    }\n    // note that possibleRowIndicesToPlacePieceOntoBoard is relative to columnIndicesOfBoard\n    // i.e. columnIndicesOfBoard = [0,1,2,3,4,5,6]\n    // i.e. possibleRowIndicesToPlacePieceOntoBoard = [3,3,4,2,1,2,1]\n    // this means board[3][0]... board[3][1]... board[4][2]... board[2][3]... board[1][4]... etc are pieces that can be placed onto the board\n    const possibleRowIndicesToPlacePieceOntoBoard = columnIndicesOfBoard.map(colIdx => findLegalRowIdxWithinColumn(board, colIdx)); // note that possibleRowIndicesToPlacePieceOntoBoard might have -1 values\n    let maxScore = null;\n    let optimalRowIdx;\n    let optimalColIdx;\n\n    const scoresForPossibleMovesArr = []; // delete this later\n\n    for (let i = 0; i < columnIndicesOfBoard.length; i++) {\n        if (possibleRowIndicesToPlacePieceOntoBoard[i] !== -1) {\n            let rowIdx = possibleRowIndicesToPlacePieceOntoBoard[i];\n            let colIdx = columnIndicesOfBoard[i];\n            let calculatedScore = calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer);\n            scoresForPossibleMovesArr.push(calculatedScore); // delete this later\n            if (maxScore === null || calculatedScore >= maxScore) {\n                maxScore = calculatedScore;\n                optimalRowIdx = rowIdx;\n                optimalColIdx = colIdx;\n            }\n        }\n    }\n    alert(scoresForPossibleMovesArr); // delete this later\n    return [optimalRowIdx, optimalColIdx];\n}\n\nexport default minimax;"]},"metadata":{},"sourceType":"module"}