{"ast":null,"code":"import deepCopy2DArray from './deepCopy2DArray';\nexport default function minimax(board, depth, alpha, beta, isMaximizingPlayer, maximizingPlayer, minimizingPlayer) {\n  /**\n   * minimax algorithm to determine how and where the ai will make its move\n   * refer to the pseudocode on wikipedia\n   * it will return the optimal rowIdx and colIdx, the location to place the piece onto the board\n   * return value looks like [optimalRowIdx, optimalColIdx, maxScore]... the 0th and 1st position of this array tell where the AI should go\n   * \n   * board is a row x col array\n   * depth tells you how far down the tree you will traverse to find the calculated score\n   * maximizingPlayer is the player that is trying to win... in this case the AI = \"ai\"\n   * minimizingPlayer is the player that is trying to prevent the maximizingPlayer from winning... in this case HUMAN = \"you\"\n   */\n  var possibleColumnIndices = getAllValidColumnPositions(board);\n  var isTheEndOfGame = isGameOver(board, maximizingPlayer, minimizingPlayer);\n\n  if (depth === 0 || isTheEndOfGame) {\n    if (isTheEndOfGame) {\n      if (isWinner(board, maximizingPlayer)) {\n        return [null, null, 99999999999];\n      } else if (isWinner(board, minimizingPlayer)) {\n        return [null, null, -99999999999];\n      } else {\n        // Game is over. A tie has occurred.\n        return [null, null, 0];\n      }\n    } else {\n      // else the depth is 0\n      return [null, null, calculateScore(board, maximizingPlayer, minimizingPlayer)];\n    }\n  }\n\n  if (isMaximizingPlayer) {\n    var maxScore = Number.MIN_VALUE;\n    var randomIdx = Math.floor(Math.random() * possibleColumnIndices.length);\n    var colIdx = possibleColumnIndices[randomIdx];\n    var rowIdx = findLegalRowIdxWithinColumn(board, colIdx);\n\n    for (var i = 0; i < possibleColumnIndices.length; i++) {\n      var currRowIdx = findLegalRowIdxWithinColumn(board, possibleColumnIndices[i]);\n      var newBoard = putPieceOntoTheBoard(currRowIdx, possibleColumnIndices[i], board, maximizingPlayer);\n      var newScore = minimax(newBoard, depth - 1, alpha, beta, false, maximizingPlayer, minimizingPlayer)[2];\n\n      if (newScore > maxScore) {\n        maxScore = newScore;\n        colIdx = possibleColumnIndices[i];\n        rowIdx = currRowIdx;\n      }\n\n      var newAlpha = Math.max(alpha, maxScore);\n\n      if (newAlpha >= beta) {\n        break;\n      }\n    }\n\n    return [rowIdx, colIdx, maxScore];\n  } else {\n    // else it's the minimizing player\n    var minScore = Number.MAX_VALUE;\n\n    var _randomIdx = Math.floor(Math.random() * possibleColumnIndices.length);\n\n    var _colIdx = possibleColumnIndices[_randomIdx];\n\n    var _rowIdx = findLegalRowIdxWithinColumn(board, _colIdx);\n\n    for (var _i = 0; _i < possibleColumnIndices.length; _i++) {\n      var _currRowIdx = findLegalRowIdxWithinColumn(board, possibleColumnIndices[_i]);\n\n      var _newBoard = putPieceOntoTheBoard(_currRowIdx, possibleColumnIndices[_i], board, minimizingPlayer);\n\n      var _newScore = minimax(_newBoard, depth - 1, alpha, beta, true, maximizingPlayer, minimizingPlayer)[2];\n\n      if (_newScore < minScore) {\n        minScore = _newScore;\n        _colIdx = possibleColumnIndices[_i];\n        _rowIdx = _currRowIdx;\n      }\n\n      var newBeta = Math.min(beta, minScore);\n\n      if (newBeta <= alpha) {\n        break;\n      }\n    }\n\n    return [_rowIdx, _colIdx, minScore];\n  }\n}\n\nfunction getAllValidColumnPositions(board) {\n  /**\n   * Returns all the possible columns that have a valid row position to place the piece onto the board\n   * The return value is an array with the elements inside being the index of the column position\n   */\n  var TOTALNUMOFCOLUMNS = board[0].length; // get all the possible moves that the player can drop onto the board\n  // will have 2 arrays: column index array and row index array\n  // refer to the note below about the relationship between these two arrays\n\n  var columnIndicesOfBoard = []; // this will look like [0,1,2,3,4,5,6]\n\n  for (var i = 0; i < TOTALNUMOFCOLUMNS; i++) {\n    columnIndicesOfBoard.push(i);\n  } // note that possibleRowIndicesToPlacePieceOntoBoard is relative to columnIndicesOfBoard\n  // i.e. columnIndicesOfBoard = [0,1,2,3,4,5,6]\n  // i.e. possibleRowIndicesToPlacePieceOntoBoard = [3,3,4,2,1,2,1]\n  // this means board[3][0]... board[3][1]... board[4][2]... board[2][3]... board[1][4]... etc are pieces that can be placed onto the board\n\n\n  var possibleRowIndicesToPlacePieceOntoBoard = columnIndicesOfBoard.map(function (colIdx) {\n    return findLegalRowIdxWithinColumn(board, colIdx);\n  }); // note that possibleRowIndicesToPlacePieceOntoBoard might have -1 values\n  // get all the columns for which the corresponding possibleRowIndicesToPlacePieceOntoBoard !== -1\n\n  var possibleColumnIndicesToPlacePieceOntoBoard = [];\n\n  for (var _i2 = 0; _i2 < columnIndicesOfBoard.length; _i2++) {\n    if (possibleRowIndicesToPlacePieceOntoBoard[_i2] !== -1) {\n      possibleColumnIndicesToPlacePieceOntoBoard.push(_i2);\n    }\n  }\n\n  return possibleColumnIndicesToPlacePieceOntoBoard;\n}\n\nfunction putPieceOntoTheBoard(rowIdx, colIdx, board, player) {\n  /**\n   * returns a new board such that the newBoard[rowIdx][colIdx] = player and the other values are the same as board\n   */\n  var newBoard = deepCopy2DArray(board);\n  newBoard[rowIdx][colIdx] = player;\n  return newBoard;\n}\n\nfunction isGameOver(board, maximizingPlayer, minimizingPlayer) {\n  if (isWinner(board, maximizingPlayer)) {\n    return true;\n  } else if (isWinner(board, minimizingPlayer)) {\n    return true;\n  } else if (isBoardAllFilled(board)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction isBoardAllFilled(board) {\n  return board.map(function (row) {\n    return row.every(function (piece) {\n      return piece !== null;\n    });\n  }).every(function (isRowFilled) {\n    return isRowFilled === true;\n  });\n}\n\nfunction isWinner(board, player) {\n  var WINDOWLENGTH = 4;\n  var TOTALNUMOFROWS = board.length;\n  var TOTALNUMOFCOLUMNS = board[0].length; // check horizontal\n\n  for (var currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    for (var offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFCOLUMNS; offset++) {\n      var horizontalFourAdjacentSquares = board[currRowIdx].slice(offset, offset + WINDOWLENGTH);\n\n      if (horizontalFourAdjacentSquares.every(function (val) {\n        return val === player;\n      })) {\n        return true;\n      }\n    }\n  } // Check vertical\n\n\n  for (var currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n    var aColumnOfSquaresArr = [];\n\n    for (var _currRowIdx2 = 0; _currRowIdx2 < TOTALNUMOFROWS; _currRowIdx2++) {\n      aColumnOfSquaresArr.push(board[_currRowIdx2][currColIdx]);\n    }\n\n    for (var _offset = 0; _offset + WINDOWLENGTH <= TOTALNUMOFROWS; _offset++) {\n      var verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(_offset, _offset + WINDOWLENGTH);\n\n      if (verticalFourAdjacentSquares.every(function (val) {\n        return val === player;\n      })) {\n        return true;\n      }\n    }\n  } // Check diagonals\n  // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx3 = Math.floor(TOTALNUMOFROWS / 2) - 1; _currRowIdx3 >= 0; _currRowIdx3--) {\n    var aDiagonalOfSquaresArr = [];\n\n    for (var runningRowIdx = _currRowIdx3, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n      aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n    }\n\n    for (var _offset2 = 0; _offset2 + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; _offset2++) {\n      var diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(_offset2, _offset2 + WINDOWLENGTH);\n\n      if (diagonalFourAdjacentSquares.every(function (val) {\n        return val === player;\n      })) {\n        return true;\n      }\n    }\n  } // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx4 = Math.floor(TOTALNUMOFROWS / 2); _currRowIdx4 < TOTALNUMOFROWS; _currRowIdx4++) {\n    var _aDiagonalOfSquaresArr = [];\n\n    for (var _runningRowIdx = _currRowIdx4, _runningColIdx = TOTALNUMOFCOLUMNS - 1; _runningRowIdx >= 0 && _runningColIdx > 0; _runningRowIdx--, _runningColIdx--) {\n      _aDiagonalOfSquaresArr.push(board[_runningRowIdx][_runningColIdx]);\n    }\n\n    for (var _offset3 = 0; _offset3 + WINDOWLENGTH <= _aDiagonalOfSquaresArr.length; _offset3++) {\n      var _diagonalFourAdjacentSquares = _aDiagonalOfSquaresArr.slice(_offset3, _offset3 + WINDOWLENGTH);\n\n      if (_diagonalFourAdjacentSquares.every(function (val) {\n        return val === player;\n      })) {\n        return true;\n      }\n    }\n  } // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx5 = Math.floor(TOTALNUMOFROWS / 2); _currRowIdx5 < TOTALNUMOFROWS; _currRowIdx5++) {\n    var _aDiagonalOfSquaresArr2 = [];\n\n    for (var _runningRowIdx2 = _currRowIdx5, _runningColIdx2 = 0; _runningRowIdx2 >= 0 && _runningColIdx2 < TOTALNUMOFCOLUMNS; _runningRowIdx2--, _runningColIdx2++) {\n      _aDiagonalOfSquaresArr2.push(board[_runningRowIdx2][_runningColIdx2]);\n    }\n\n    for (var _offset4 = 0; _offset4 + WINDOWLENGTH <= _aDiagonalOfSquaresArr2.length; _offset4++) {\n      var _diagonalFourAdjacentSquares2 = _aDiagonalOfSquaresArr2.slice(_offset4, _offset4 + WINDOWLENGTH);\n\n      if (_diagonalFourAdjacentSquares2.every(function (val) {\n        return val === player;\n      })) {\n        return true;\n      }\n    }\n  } // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx6 = Math.floor(TOTALNUMOFROWS / 2) - 1; _currRowIdx6 >= 0; _currRowIdx6--) {\n    var _aDiagonalOfSquaresArr3 = [];\n\n    for (var _runningRowIdx3 = _currRowIdx6, _runningColIdx3 = TOTALNUMOFCOLUMNS - 1; _runningRowIdx3 < TOTALNUMOFROWS && _runningColIdx3 > 0; _runningRowIdx3++, _runningColIdx3--) {\n      _aDiagonalOfSquaresArr3.push(board[_runningRowIdx3][_runningColIdx3]);\n    }\n\n    for (var _offset5 = 0; _offset5 + WINDOWLENGTH <= _aDiagonalOfSquaresArr3.length; _offset5++) {\n      var _diagonalFourAdjacentSquares3 = _aDiagonalOfSquaresArr3.slice(_offset5, _offset5 + WINDOWLENGTH);\n\n      if (_diagonalFourAdjacentSquares3.every(function (val) {\n        return val === player;\n      })) {\n        return true;\n      }\n    }\n  } // if you reach here, there is no winner\n\n\n  return false;\n}\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n  /**\n   * Returns the row index of a legal square that can be filled given the board (2 dimensional row x col).\n   * Note the legal square will be within the same column as selectedColIdx.\n   * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n   */\n  var didNotFindLegalRowIdxWithinColumnIdx = -1;\n\n  for (var rowIdx = 0; rowIdx < board.length; rowIdx++) {\n    if (board[rowIdx][selectedColIdx] === null) {\n      return rowIdx;\n    }\n  }\n\n  return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, maximizingPlayer, minimizingPlayer) {\n  /**\n   * Returns the score for the given arr, assuming the length of the arr is 4\n   */\n  var score = 0;\n\n  if (arr.filter(function (val) {\n    return val === maximizingPlayer;\n  }).length === 3 && arr.filter(function (val) {\n    return val === null;\n  }).length === 1) {\n    score += 15;\n  } else if (arr.filter(function (val) {\n    return val === maximizingPlayer;\n  }).length === 2 && arr.filter(function (val) {\n    return val === null;\n  }).length === 2) {\n    score += 2;\n  }\n\n  if (arr.filter(function (val) {\n    return val === minimizingPlayer;\n  }).length === 3 && arr.filter(function (val) {\n    return val === null;\n  }).length === 1) {\n    score -= 4;\n  }\n\n  return score;\n}\n\nfunction calculateScore(board, maximizingPlayer, minimizingPlayer) {\n  /**\n   * Returns the score for placing maximizingPlayer's piece onto the board whose location is rowIdx and colIdx.\n   */\n  var score = 0;\n  var TOTALNUMOFROWS = board.length;\n  var TOTALNUMOFCOLUMNS = board[0].length;\n  var WINDOWLENGTH = 4;\n  var CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2); // score for center piece (preference center location)\n\n  for (var currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    if (board[currRowIdx][CENTERCOLUMNIDX] === maximizingPlayer) {\n      score += 3;\n    }\n  } // Score for horizontal\n  // Scores are calculated for window lengths of 4\n\n\n  for (var _currRowIdx7 = 0; _currRowIdx7 < TOTALNUMOFROWS; _currRowIdx7++) {\n    for (var offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFCOLUMNS; offset++) {\n      var horizontalFourAdjacentSquares = board[_currRowIdx7].slice(offset, offset + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Score for vertical\n  // Scores are calculated for window lengths of 4\n\n\n  for (var currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n    var aColumnOfSquaresArr = [];\n\n    for (var _currRowIdx8 = 0; _currRowIdx8 < TOTALNUMOFROWS; _currRowIdx8++) {\n      aColumnOfSquaresArr.push(board[_currRowIdx8][currColIdx]);\n    }\n\n    for (var _offset6 = 0; _offset6 + WINDOWLENGTH <= TOTALNUMOFROWS; _offset6++) {\n      var verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(_offset6, _offset6 + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Score for diagonal\n  // Scores are calculated for window lengths of 4\n  // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx9 = Math.floor(TOTALNUMOFROWS / 2) - 1; _currRowIdx9 >= 0; _currRowIdx9--) {\n    var aDiagonalOfSquaresArr = [];\n\n    for (var runningRowIdx = _currRowIdx9, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n      aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n    }\n\n    for (var _offset7 = 0; _offset7 + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; _offset7++) {\n      var diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(_offset7, _offset7 + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx10 = Math.floor(TOTALNUMOFROWS / 2); _currRowIdx10 < TOTALNUMOFROWS; _currRowIdx10++) {\n    var _aDiagonalOfSquaresArr4 = [];\n\n    for (var _runningRowIdx4 = _currRowIdx10, _runningColIdx4 = TOTALNUMOFCOLUMNS - 1; _runningRowIdx4 >= 0 && _runningColIdx4 > 0; _runningRowIdx4--, _runningColIdx4--) {\n      _aDiagonalOfSquaresArr4.push(board[_runningRowIdx4][_runningColIdx4]);\n    }\n\n    for (var _offset8 = 0; _offset8 + WINDOWLENGTH <= _aDiagonalOfSquaresArr4.length; _offset8++) {\n      var _diagonalFourAdjacentSquares4 = _aDiagonalOfSquaresArr4.slice(_offset8, _offset8 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares4, maximizingPlayer, minimizingPlayer);\n    }\n  } // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx11 = Math.floor(TOTALNUMOFROWS / 2); _currRowIdx11 < TOTALNUMOFROWS; _currRowIdx11++) {\n    var _aDiagonalOfSquaresArr5 = [];\n\n    for (var _runningRowIdx5 = _currRowIdx11, _runningColIdx5 = 0; _runningRowIdx5 >= 0 && _runningColIdx5 < TOTALNUMOFCOLUMNS; _runningRowIdx5--, _runningColIdx5++) {\n      _aDiagonalOfSquaresArr5.push(board[_runningRowIdx5][_runningColIdx5]);\n    }\n\n    for (var _offset9 = 0; _offset9 + WINDOWLENGTH <= _aDiagonalOfSquaresArr5.length; _offset9++) {\n      var _diagonalFourAdjacentSquares5 = _aDiagonalOfSquaresArr5.slice(_offset9, _offset9 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares5, maximizingPlayer, minimizingPlayer);\n    }\n  } // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx12 = Math.floor(TOTALNUMOFROWS / 2) - 1; _currRowIdx12 >= 0; _currRowIdx12--) {\n    var _aDiagonalOfSquaresArr6 = [];\n\n    for (var _runningRowIdx6 = _currRowIdx12, _runningColIdx6 = TOTALNUMOFCOLUMNS - 1; _runningRowIdx6 < TOTALNUMOFROWS && _runningColIdx6 > 0; _runningRowIdx6++, _runningColIdx6--) {\n      _aDiagonalOfSquaresArr6.push(board[_runningRowIdx6][_runningColIdx6]);\n    }\n\n    for (var _offset10 = 0; _offset10 + WINDOWLENGTH <= _aDiagonalOfSquaresArr6.length; _offset10++) {\n      var _diagonalFourAdjacentSquares6 = _aDiagonalOfSquaresArr6.slice(_offset10, _offset10 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares6, maximizingPlayer, minimizingPlayer);\n    }\n  }\n\n  return score;\n}","map":{"version":3,"sources":["/Users/kevintsai/Desktop/resume_website/components/portfolio/connect4/minimax.js"],"names":["deepCopy2DArray","minimax","board","depth","alpha","beta","isMaximizingPlayer","maximizingPlayer","minimizingPlayer","possibleColumnIndices","getAllValidColumnPositions","isTheEndOfGame","isGameOver","isWinner","calculateScore","maxScore","Number","MIN_VALUE","randomIdx","Math","floor","random","length","colIdx","rowIdx","findLegalRowIdxWithinColumn","i","currRowIdx","newBoard","putPieceOntoTheBoard","newScore","newAlpha","max","minScore","MAX_VALUE","newBeta","min","TOTALNUMOFCOLUMNS","columnIndicesOfBoard","push","possibleRowIndicesToPlacePieceOntoBoard","map","possibleColumnIndicesToPlacePieceOntoBoard","player","isBoardAllFilled","row","every","piece","isRowFilled","WINDOWLENGTH","TOTALNUMOFROWS","offset","horizontalFourAdjacentSquares","slice","val","currColIdx","aColumnOfSquaresArr","verticalFourAdjacentSquares","aDiagonalOfSquaresArr","runningRowIdx","runningColIdx","diagonalFourAdjacentSquares","selectedColIdx","didNotFindLegalRowIdxWithinColumnIdx","calculateScoreForThese4Squares","arr","score","filter","CENTERCOLUMNIDX"],"mappings":"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","sourcesContent":["import deepCopy2DArray from './deepCopy2DArray';\n\nexport default function minimax(board, depth, alpha, beta, isMaximizingPlayer, maximizingPlayer, minimizingPlayer) {\n    /**\n     * minimax algorithm to determine how and where the ai will make its move\n     * refer to the pseudocode on wikipedia\n     * it will return the optimal rowIdx and colIdx, the location to place the piece onto the board\n     * return value looks like [optimalRowIdx, optimalColIdx, maxScore]... the 0th and 1st position of this array tell where the AI should go\n     * \n     * board is a row x col array\n     * depth tells you how far down the tree you will traverse to find the calculated score\n     * maximizingPlayer is the player that is trying to win... in this case the AI = \"ai\"\n     * minimizingPlayer is the player that is trying to prevent the maximizingPlayer from winning... in this case HUMAN = \"you\"\n     */\n\n    const possibleColumnIndices = getAllValidColumnPositions(board);\n    const isTheEndOfGame = isGameOver(board, maximizingPlayer, minimizingPlayer);\n\n    if (depth === 0 || isTheEndOfGame) {\n        if (isTheEndOfGame) {\n            if (isWinner(board, maximizingPlayer)) {\n                return [null, null, 99999999999];\n            } else if (isWinner(board, minimizingPlayer)) {\n                return [null, null, -99999999999];\n            } else {    // Game is over. A tie has occurred.\n                return [null, null, 0];\n            }\n        }\n        else { // else the depth is 0\n            return [null, null, calculateScore(board, maximizingPlayer, minimizingPlayer)];\n        }\n    }\n\n    if (isMaximizingPlayer) {\n        let maxScore = Number.MIN_VALUE;\n        let randomIdx = Math.floor(Math.random() * possibleColumnIndices.length);\n        let colIdx = possibleColumnIndices[randomIdx];        \n        let rowIdx = findLegalRowIdxWithinColumn(board, colIdx);\n\n        for (let i = 0; i < possibleColumnIndices.length; i++) {\n            let currRowIdx = findLegalRowIdxWithinColumn(board, possibleColumnIndices[i]);\n            const newBoard = putPieceOntoTheBoard(currRowIdx, possibleColumnIndices[i], board, maximizingPlayer);\n            const newScore = minimax(newBoard, depth - 1, alpha, beta, false, maximizingPlayer, minimizingPlayer)[2];\n            if (newScore > maxScore) {\n                maxScore = newScore;\n                colIdx = possibleColumnIndices[i];\n                rowIdx = currRowIdx;\n            }\n            let newAlpha = Math.max(alpha, maxScore);\n            if (newAlpha >= beta) {\n                break;\n            }\n        }\n        return [rowIdx, colIdx, maxScore];\n    } else { // else it's the minimizing player\n        let minScore = Number.MAX_VALUE;\n        let randomIdx = Math.floor(Math.random() * possibleColumnIndices.length);\n        let colIdx = possibleColumnIndices[randomIdx];        \n        let rowIdx = findLegalRowIdxWithinColumn(board, colIdx);\n\n        for (let i = 0; i < possibleColumnIndices.length; i++) {\n            let currRowIdx = findLegalRowIdxWithinColumn(board, possibleColumnIndices[i]);\n            const newBoard = putPieceOntoTheBoard(currRowIdx, possibleColumnIndices[i], board, minimizingPlayer);\n            const newScore = minimax(newBoard, depth - 1, alpha, beta, true, maximizingPlayer, minimizingPlayer)[2];\n            if (newScore < minScore) {\n                minScore = newScore;\n                colIdx = possibleColumnIndices[i];\n                rowIdx = currRowIdx;\n            }\n            let newBeta = Math.min(beta, minScore);\n            if (newBeta <= alpha) {\n                break;\n            }\n        }\n        return [rowIdx, colIdx, minScore];\n    }\n}\n\nfunction getAllValidColumnPositions(board) {\n    /**\n     * Returns all the possible columns that have a valid row position to place the piece onto the board\n     * The return value is an array with the elements inside being the index of the column position\n     */\n\n    const TOTALNUMOFCOLUMNS = board[0].length;\n\n    // get all the possible moves that the player can drop onto the board\n    // will have 2 arrays: column index array and row index array\n    // refer to the note below about the relationship between these two arrays\n    const columnIndicesOfBoard = []; // this will look like [0,1,2,3,4,5,6]\n    for (let i = 0; i < TOTALNUMOFCOLUMNS; i++) {\n        columnIndicesOfBoard.push(i);\n    }\n\n    // note that possibleRowIndicesToPlacePieceOntoBoard is relative to columnIndicesOfBoard\n    // i.e. columnIndicesOfBoard = [0,1,2,3,4,5,6]\n    // i.e. possibleRowIndicesToPlacePieceOntoBoard = [3,3,4,2,1,2,1]\n    // this means board[3][0]... board[3][1]... board[4][2]... board[2][3]... board[1][4]... etc are pieces that can be placed onto the board\n    const possibleRowIndicesToPlacePieceOntoBoard = columnIndicesOfBoard.map(colIdx => findLegalRowIdxWithinColumn(board, colIdx)); // note that possibleRowIndicesToPlacePieceOntoBoard might have -1 values\n\n    // get all the columns for which the corresponding possibleRowIndicesToPlacePieceOntoBoard !== -1\n    const possibleColumnIndicesToPlacePieceOntoBoard = []\n    for (let i = 0; i < columnIndicesOfBoard.length; i++) {\n        if (possibleRowIndicesToPlacePieceOntoBoard[i] !== -1) {\n            possibleColumnIndicesToPlacePieceOntoBoard.push(i);\n        }\n    }\n\n    return possibleColumnIndicesToPlacePieceOntoBoard;\n}\n\nfunction putPieceOntoTheBoard(rowIdx, colIdx, board, player) {\n    /**\n     * returns a new board such that the newBoard[rowIdx][colIdx] = player and the other values are the same as board\n     */\n\n    const newBoard = deepCopy2DArray(board);\n    newBoard[rowIdx][colIdx] = player;\n\n    return newBoard;\n}\n\nfunction isGameOver(board, maximizingPlayer, minimizingPlayer) {\n    if (isWinner(board, maximizingPlayer)) {\n        return true;\n    } else if (isWinner(board, minimizingPlayer)) {\n        return true;\n    } else if (isBoardAllFilled(board)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction isBoardAllFilled(board) {\n    return board.map(row => row.every(piece => piece !== null)).every(isRowFilled => isRowFilled === true);\n}\n\nfunction isWinner(board, player) {\n    const WINDOWLENGTH = 4;\n    const TOTALNUMOFROWS = board.length;\n    const TOTALNUMOFCOLUMNS = board[0].length;\n\n    // check horizontal\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFCOLUMNS; offset++) {\n            const horizontalFourAdjacentSquares = board[currRowIdx].slice(offset, offset + WINDOWLENGTH);\n            if (horizontalFourAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }\n    }\n\n    // Check vertical\n    for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n        const aColumnOfSquaresArr = [];\n        for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n            aColumnOfSquaresArr.push(board[currRowIdx][currColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFROWS; offset++) {\n            const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            if (verticalFourAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }\n    }\n\n    // Check diagonals\n\n    // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n            aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            if (diagonalFourAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }\n    }\n\n    // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx >= 0 && runningColIdx > 0; runningRowIdx--, runningColIdx--) {\n            aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            if (diagonalFourAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }\n    }\n\n    // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx >= 0 && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx--, runningColIdx++) {\n            aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            if (diagonalFourAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }\n    }\n\n    // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx < TOTALNUMOFROWS && runningColIdx > 0; runningRowIdx++, runningColIdx--) {\n            aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            if (diagonalFourAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }\n    }\n\n    // if you reach here, there is no winner\n    return false;\n\n}\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n    /**\n     * Returns the row index of a legal square that can be filled given the board (2 dimensional row x col).\n     * Note the legal square will be within the same column as selectedColIdx.\n     * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n     */\n    const didNotFindLegalRowIdxWithinColumnIdx = -1;\n    for (let rowIdx = 0; rowIdx < board.length; rowIdx++) {\n        if (board[rowIdx][selectedColIdx] === null) {\n            return rowIdx;\n        }\n    }\n    return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, maximizingPlayer, minimizingPlayer) {\n    /**\n     * Returns the score for the given arr, assuming the length of the arr is 4\n     */\n\n    let score = 0;\n\n    if (arr.filter(val => val === maximizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score += 15;\n    } else if (arr.filter(val => val === maximizingPlayer).length === 2 && arr.filter(val => val === null).length === 2) {\n        score += 2;\n    }\n\n    if (arr.filter(val => val === minimizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score -= 4;\n    }\n\n    return score;\n}\n\nfunction calculateScore(board, maximizingPlayer, minimizingPlayer) {\n    /**\n     * Returns the score for placing maximizingPlayer's piece onto the board whose location is rowIdx and colIdx.\n     */\n\n    let score = 0;\n\n    const TOTALNUMOFROWS = board.length;\n    const TOTALNUMOFCOLUMNS = board[0].length;\n    const WINDOWLENGTH = 4;\n    const CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n\n    // score for center piece (preference center location)\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        if (board[currRowIdx][CENTERCOLUMNIDX] === maximizingPlayer) {\n            score += 3;\n        }\n    }\n\n\n    // Score for horizontal\n    // Scores are calculated for window lengths of 4\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFCOLUMNS; offset++) {\n            const horizontalFourAdjacentSquares = board[currRowIdx].slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Score for vertical\n    // Scores are calculated for window lengths of 4\n    for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n        const aColumnOfSquaresArr = [];\n        for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n            aColumnOfSquaresArr.push(board[currRowIdx][currColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFROWS; offset++) {\n            const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Score for diagonal\n    // Scores are calculated for window lengths of 4\n\n    // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n            aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx >= 0 && runningColIdx > 0; runningRowIdx--, runningColIdx--) {\n            aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx >= 0 && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx--, runningColIdx++) {\n            aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx < TOTALNUMOFROWS && runningColIdx > 0; runningRowIdx++, runningColIdx--) {\n            aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    return score;\n}"]},"metadata":{},"sourceType":"module"}