{"ast":null,"code":"import deepCopy2DArray from './deepCopy2DArray';\nexport default function minimax(board, depth, isMaximizingPlayer, maximizingPlayer, minimizingPlayer) {\n  /**\n   * minimax algorithm to determine how and where the ai will make its move\n   * refer to the pseudocode on wikipedia\n   * it will return the optimal rowIdx and colIdx, the location to place the piece onto the board\n   * return value looks like [optimalRowIdx, optimalColIdx]\n   * \n   * board is a row x col array\n   * depth tells you how far down the tree you will traverse to find the calculated score\n   * maximizingPlayer is the player that is trying to win... in this case the AI = \"ai\"\n   * minimizingPlayer is the player that is trying to prevent the maximizingPlayer from winning... in this case HUMAN = \"you\"\n   */\n  let maxScore = null;\n  let optimalRowIdx;\n  let optimalColIdx;\n  const isTheEndOfGame = isGameOver(board, maximizingPlayer, minimizingPlayer);\n\n  if (depth === 0 || isTheEndOfGame) {\n    if (isTheEndOfGame) {\n      if (isWinner(board, maximizingPlayer)) {\n        return Number.MAX_VALUE - 1;\n      } else if (isWinner(board, minimizingPlayer)) {\n        return Number.MIN_VALUE + 1;\n      } else {\n        // Game is over. A tie has occurred.\n        return 0;\n      }\n    } else {\n      // else the depth is 0\n      return calculateScore(board, maximizingPlayer, minimizingPlayer);\n    }\n  }\n\n  if (isMaximizingPlayer) {\n    let maxValue = Number.MIN_VALUE;\n  }\n\n  return [optimalRowIdx, optimalColIdx];\n}\n\nfunction getAllValidColumnPositions(board) {\n  /**\n   * Returns all the possible columns that have a valid row position to place the piece onto the board\n   * The return value is an array with the elements inside being the index of the column position\n   */\n  const TOTALNUMOFCOLUMNS = board[0].length; // get all the possible moves that the player can drop onto the board\n  // will have 2 arrays: column index array and row index array\n  // refer to the note below about the relationship between these two arrays\n\n  const columnIndicesOfBoard = []; // this will look like [0,1,2,3,4,5,6]\n\n  for (let i = 0; i < TOTALNUMOFCOLUMNS; i++) {\n    columnIndicesOfBoard.push(i);\n  } // note that possibleRowIndicesToPlacePieceOntoBoard is relative to columnIndicesOfBoard\n  // i.e. columnIndicesOfBoard = [0,1,2,3,4,5,6]\n  // i.e. possibleRowIndicesToPlacePieceOntoBoard = [3,3,4,2,1,2,1]\n  // this means board[3][0]... board[3][1]... board[4][2]... board[2][3]... board[1][4]... etc are pieces that can be placed onto the board\n\n\n  const possibleRowIndicesToPlacePieceOntoBoard = columnIndicesOfBoard.map(colIdx => findLegalRowIdxWithinColumn(board, colIdx)); // note that possibleRowIndicesToPlacePieceOntoBoard might have -1 values\n  // get all the columns for which the corresponding possibleRowIndicesToPlacePieceOntoBoard !== -1\n\n  const possibleColumnIndicesToPlacePieceOntoBoard = [];\n\n  for (let i = 0; i < columnIndicesOfBoard.length; i++) {\n    if (possibleRowIndicesToPlacePieceOntoBoard[i] !== -1) {\n      possibleColumnIndicesToPlacePieceOntoBoard.push(i);\n    }\n  }\n}\n\nfunction putPieceOntoTheBoard(rowIdx, colIdx, board, player) {\n  /**\n   * returns a new board such that the newBoard[rowIdx][colIdx] = player and the other values are the same as board\n   */\n  const newBoard = deepCopy2DArray(board);\n  newBoard[rowIdx][colIdx] = player;\n  return newBoard;\n}\n\nfunction isGameOver(board, maximizingPlayer, minimizingPlayer) {\n  if (isWinner(board, maximizingPlayer)) {\n    return true;\n  } else if (isWinner(board, minimizingPlayer)) {\n    return true;\n  } else if (isBoardAllFilled(board)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction isBoardAllFilled(board) {\n  return board.map(row => row.every(piece => piece !== null)).every(isRowFilled => isRowFilled === true);\n}\n\nfunction isWinner(board, player) {\n  const WINDOWLENGTH = 4;\n  const TOTALNUMOFROWS = board.length;\n  const TOTALNUMOFCOLUMNS = board[0].length; // check horizontal\n\n  for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFCOLUMNS; offset++) {\n      const horizontalFourAdjacentSquares = newBoard[currRowIdx].slice(offset, offset + WINDOWLENGTH);\n\n      if (horizontalFourAdjacentSquares.every(val => val === player)) {\n        return true;\n      }\n    }\n  } // Check vertical\n\n\n  for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n    const aColumnOfSquaresArr = [];\n\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n      aColumnOfSquaresArr.push(newBoard[currRowIdx][currColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFROWS; offset++) {\n      const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n\n      if (verticalFourAdjacentSquares.every(val => val === player)) {\n        return true;\n      }\n    }\n  } // Check diagonals\n  // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n    const aDiagonalOfSquaresArr = [];\n\n    for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n      aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n\n      if (diagonalFourAdjacentSquares.every(val => val === player)) {\n        return true;\n      }\n    }\n  } // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    const aDiagonalOfSquaresArr = [];\n\n    for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx >= 0 && runningColIdx > 0; runningRowIdx--, runningColIdx--) {\n      aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n\n      if (diagonalFourAdjacentSquares.every(val => val === player)) {\n        return true;\n      }\n    }\n  } // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    const aDiagonalOfSquaresArr = [];\n\n    for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx >= 0 && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx--, runningColIdx++) {\n      aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n\n      if (diagonalFourAdjacentSquares.every(val => val === player)) {\n        return true;\n      }\n    }\n  } // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n    const aDiagonalOfSquaresArr = [];\n\n    for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx < TOTALNUMOFROWS && runningColIdx > 0; runningRowIdx++, runningColIdx--) {\n      aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n\n      if (diagonalFourAdjacentSquares.every(val => val === player)) {\n        return true;\n      }\n    }\n  } // if you reach here, there is no winner\n\n\n  return false;\n}\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n  /**\n   * Returns the row index of a legal square that can be filled given the board (2 dimensional row x col).\n   * Note the legal square will be within the same column as selectedColIdx.\n   * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n   */\n  const didNotFindLegalRowIdxWithinColumnIdx = -1;\n\n  for (let rowIdx = 0; rowIdx < board.length; rowIdx++) {\n    if (board[rowIdx][selectedColIdx] === null) {\n      return rowIdx;\n    }\n  }\n\n  return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, maximizingPlayer, minimizingPlayer) {\n  /**\n   * Returns the score for the given arr, assuming the length of the arr is 4\n   */\n  let score = 0;\n\n  if (arr.filter(val => val === maximizingPlayer).length === 4) {\n    score += 100;\n  } else if (arr.filter(val => val === maximizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n    score += 5;\n  } else if (arr.filter(val => val === maximizingPlayer).length === 2 && arr.filter(val => val === null).length === 2) {\n    score += 2;\n  }\n\n  if (arr.filter(val => val === minimizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n    score -= 15;\n  }\n\n  return score;\n}\n\nfunction calculateScore(board, maximizingPlayer, minimizingPlayer) {\n  /**\n   * Returns the score for placing maximizingPlayer's piece onto the board whose location is rowIdx and colIdx.\n   */\n  let score = 0;\n  const TOTALNUMOFROWS = board.length;\n  const TOTALNUMOFCOLUMNS = board[0].length;\n  const WINDOWLENGTH = 4;\n  const CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2); // score for center piece (preference center location)\n\n  for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    if (board[currRowIdx][CENTERCOLUMNIDX] === maximizingPlayer) {\n      score += 2;\n    }\n  } // Score for horizontal\n  // Scores are calculated for window lengths of 4\n\n\n  for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFCOLUMNS; offset++) {\n      const horizontalFourAdjacentSquares = board[currRowIdx].slice(offset, offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Score for vertical\n  // Scores are calculated for window lengths of 4\n\n\n  for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n    const aColumnOfSquaresArr = [];\n\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n      aColumnOfSquaresArr.push(board[currRowIdx][currColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFROWS; offset++) {\n      const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Score for diagonal\n  // Scores are calculated for window lengths of 4\n  // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n    const aDiagonalOfSquaresArr = [];\n\n    for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n      aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    const aDiagonalOfSquaresArr = [];\n\n    for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx >= 0 && runningColIdx > 0; runningRowIdx--, runningColIdx--) {\n      aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    const aDiagonalOfSquaresArr = [];\n\n    for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx >= 0 && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx--, runningColIdx++) {\n      aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n    const aDiagonalOfSquaresArr = [];\n\n    for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx < TOTALNUMOFROWS && runningColIdx > 0; runningRowIdx++, runningColIdx--) {\n      aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n    }\n\n    for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n      const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  }\n\n  return score;\n}","map":{"version":3,"sources":["/Users/kevintsai/Desktop/resume_website/components/portfolio/connect4/minimax.js"],"names":["deepCopy2DArray","minimax","board","depth","isMaximizingPlayer","maximizingPlayer","minimizingPlayer","maxScore","optimalRowIdx","optimalColIdx","isTheEndOfGame","isGameOver","isWinner","Number","MAX_VALUE","MIN_VALUE","calculateScore","maxValue","getAllValidColumnPositions","TOTALNUMOFCOLUMNS","length","columnIndicesOfBoard","i","push","possibleRowIndicesToPlacePieceOntoBoard","map","colIdx","findLegalRowIdxWithinColumn","possibleColumnIndicesToPlacePieceOntoBoard","putPieceOntoTheBoard","rowIdx","player","newBoard","isBoardAllFilled","row","every","piece","isRowFilled","WINDOWLENGTH","TOTALNUMOFROWS","currRowIdx","offset","horizontalFourAdjacentSquares","slice","val","currColIdx","aColumnOfSquaresArr","verticalFourAdjacentSquares","Math","floor","aDiagonalOfSquaresArr","runningRowIdx","runningColIdx","diagonalFourAdjacentSquares","selectedColIdx","didNotFindLegalRowIdxWithinColumnIdx","calculateScoreForThese4Squares","arr","score","filter","CENTERCOLUMNIDX"],"mappings":"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","sourcesContent":["import deepCopy2DArray from './deepCopy2DArray';\n\nexport default function minimax(board, depth, isMaximizingPlayer, maximizingPlayer, minimizingPlayer) {\n    /**\n     * minimax algorithm to determine how and where the ai will make its move\n     * refer to the pseudocode on wikipedia\n     * it will return the optimal rowIdx and colIdx, the location to place the piece onto the board\n     * return value looks like [optimalRowIdx, optimalColIdx]\n     * \n     * board is a row x col array\n     * depth tells you how far down the tree you will traverse to find the calculated score\n     * maximizingPlayer is the player that is trying to win... in this case the AI = \"ai\"\n     * minimizingPlayer is the player that is trying to prevent the maximizingPlayer from winning... in this case HUMAN = \"you\"\n     */\n\n\n\n    let maxScore = null;\n    let optimalRowIdx;\n    let optimalColIdx;\n\n\n    const isTheEndOfGame = isGameOver(board, maximizingPlayer, minimizingPlayer);\n\n    if (depth === 0 || isTheEndOfGame) {\n        if (isTheEndOfGame) {\n            if (isWinner(board, maximizingPlayer)) {\n                return Number.MAX_VALUE - 1;\n            } else if (isWinner(board, minimizingPlayer)) {\n                return Number.MIN_VALUE + 1;\n            } else {    // Game is over. A tie has occurred.\n                return 0;\n            }\n        }\n        else { // else the depth is 0\n            return calculateScore(board, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    if (isMaximizingPlayer) {\n        let maxValue = Number.MIN_VALUE;\n        \n    }\n\n    return [optimalRowIdx, optimalColIdx];\n}\n\nfunction getAllValidColumnPositions(board) {\n    /**\n     * Returns all the possible columns that have a valid row position to place the piece onto the board\n     * The return value is an array with the elements inside being the index of the column position\n     */\n\n    const TOTALNUMOFCOLUMNS = board[0].length;\n\n    // get all the possible moves that the player can drop onto the board\n    // will have 2 arrays: column index array and row index array\n    // refer to the note below about the relationship between these two arrays\n    const columnIndicesOfBoard = []; // this will look like [0,1,2,3,4,5,6]\n    for (let i = 0; i < TOTALNUMOFCOLUMNS; i++) {\n        columnIndicesOfBoard.push(i);\n    }\n\n    // note that possibleRowIndicesToPlacePieceOntoBoard is relative to columnIndicesOfBoard\n    // i.e. columnIndicesOfBoard = [0,1,2,3,4,5,6]\n    // i.e. possibleRowIndicesToPlacePieceOntoBoard = [3,3,4,2,1,2,1]\n    // this means board[3][0]... board[3][1]... board[4][2]... board[2][3]... board[1][4]... etc are pieces that can be placed onto the board\n    const possibleRowIndicesToPlacePieceOntoBoard = columnIndicesOfBoard.map(colIdx => findLegalRowIdxWithinColumn(board, colIdx)); // note that possibleRowIndicesToPlacePieceOntoBoard might have -1 values\n\n    // get all the columns for which the corresponding possibleRowIndicesToPlacePieceOntoBoard !== -1\n    const possibleColumnIndicesToPlacePieceOntoBoard = []\n    for (let i = 0; i < columnIndicesOfBoard.length; i++) {\n        if (possibleRowIndicesToPlacePieceOntoBoard[i] !== -1) {\n            possibleColumnIndicesToPlacePieceOntoBoard.push(i);\n        }\n    }\n}\n\nfunction putPieceOntoTheBoard(rowIdx, colIdx, board, player) {\n    /**\n     * returns a new board such that the newBoard[rowIdx][colIdx] = player and the other values are the same as board\n     */\n\n    const newBoard = deepCopy2DArray(board);\n    newBoard[rowIdx][colIdx] = player;\n\n    return newBoard;\n}\n\nfunction isGameOver(board, maximizingPlayer, minimizingPlayer) {\n    if (isWinner(board, maximizingPlayer)) {\n        return true;\n    } else if (isWinner(board, minimizingPlayer)) {\n        return true;\n    } else if (isBoardAllFilled(board)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction isBoardAllFilled(board) {\n    return board.map(row => row.every(piece => piece !== null)).every(isRowFilled => isRowFilled === true);\n}\n\nfunction isWinner(board, player) {\n    const WINDOWLENGTH = 4;\n    const TOTALNUMOFROWS = board.length;\n    const TOTALNUMOFCOLUMNS = board[0].length;\n\n    // check horizontal\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFCOLUMNS; offset++) {\n            const horizontalFourAdjacentSquares = newBoard[currRowIdx].slice(offset, offset + WINDOWLENGTH);\n            if (horizontalFourAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }\n    }\n\n    // Check vertical\n    for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n        const aColumnOfSquaresArr = [];\n        for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n            aColumnOfSquaresArr.push(newBoard[currRowIdx][currColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFROWS; offset++) {\n            const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            if (verticalFourAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }\n    }\n\n    // Check diagonals\n\n    // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n            aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            if (diagonalFourAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }\n    }\n\n    // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx >= 0 && runningColIdx > 0; runningRowIdx--, runningColIdx--) {\n            aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            if (diagonalFourAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }\n    }\n\n    // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx >= 0 && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx--, runningColIdx++) {\n            aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            if (diagonalFourAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }\n    }\n\n    // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx < TOTALNUMOFROWS && runningColIdx > 0; runningRowIdx++, runningColIdx--) {\n            aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            if (diagonalFourAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }\n    }\n\n    // if you reach here, there is no winner\n    return false;\n\n}\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n    /**\n     * Returns the row index of a legal square that can be filled given the board (2 dimensional row x col).\n     * Note the legal square will be within the same column as selectedColIdx.\n     * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n     */\n    const didNotFindLegalRowIdxWithinColumnIdx = -1;\n    for (let rowIdx = 0; rowIdx < board.length; rowIdx++) {\n        if (board[rowIdx][selectedColIdx] === null) {\n            return rowIdx;\n        }\n    }\n    return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, maximizingPlayer, minimizingPlayer) {\n    /**\n     * Returns the score for the given arr, assuming the length of the arr is 4\n     */\n\n    let score = 0;\n\n    if (arr.filter(val => val === maximizingPlayer).length === 4) {\n        score += 100;\n    } else if (arr.filter(val => val === maximizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score += 5;\n    } else if (arr.filter(val => val === maximizingPlayer).length === 2 && arr.filter(val => val === null).length === 2) {\n        score += 2;\n    }\n\n    if (arr.filter(val => val === minimizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score -= 15;\n    }\n\n    return score;\n}\n\nfunction calculateScore(board, maximizingPlayer, minimizingPlayer) {\n    /**\n     * Returns the score for placing maximizingPlayer's piece onto the board whose location is rowIdx and colIdx.\n     */\n\n    let score = 0;\n\n    const TOTALNUMOFROWS = board.length;\n    const TOTALNUMOFCOLUMNS = board[0].length;\n    const WINDOWLENGTH = 4;\n    const CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n\n    // score for center piece (preference center location)\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        if (board[currRowIdx][CENTERCOLUMNIDX] === maximizingPlayer) {\n            score += 2;\n        }\n    }\n\n\n    // Score for horizontal\n    // Scores are calculated for window lengths of 4\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFCOLUMNS; offset++) {\n            const horizontalFourAdjacentSquares = board[currRowIdx].slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Score for vertical\n    // Scores are calculated for window lengths of 4\n    for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n        const aColumnOfSquaresArr = [];\n        for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n            aColumnOfSquaresArr.push(board[currRowIdx][currColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFROWS; offset++) {\n            const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Score for diagonal\n    // Scores are calculated for window lengths of 4\n\n    // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n            aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx >= 0 && runningColIdx > 0; runningRowIdx--, runningColIdx--) {\n            aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx >= 0 && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx--, runningColIdx++) {\n            aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx < TOTALNUMOFROWS && runningColIdx > 0; runningRowIdx++, runningColIdx--) {\n            aDiagonalOfSquaresArr.push(board[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    return score;\n}"]},"metadata":{},"sourceType":"module"}