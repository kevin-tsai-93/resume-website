{"ast":null,"code":"function calculateScoreForMove(board, player, idx) {\n  /**\n   * Returns the score for placing player's piece onto the board whose location is idx.\n   */\n  var score = 0;\n  var WINDOWLENGTH = 4; // Score for horizontal\n\n  var frontOfRowIdx = idx - idx % 7;\n  var rowArr = board.slice(frontOfRowIdx, frontOfRowIdx + 7);\n\n  for (var frontIdx = 0; cutOffIdx < WINDOWLENGTH; cutOffIdx++) {\n    var windowArr = rowArr.slice(frontIdx, frontIdx + WINDOWLENGTH);\n\n    if (windowArr.filter(function (val) {\n      return val === player;\n    }).length === 4) {\n      score += 100;\n    } else if (windowArr.filter(function (val) {\n      return val === player;\n    }).length === 3 && windowArr.filter(function (val) {\n      return val === null;\n    }).length === 1) {\n      score += 5;\n    }\n  }\n\n  score += calculateScoreHorizontal(board, idx);\n}\n\nfunction calculateWinner(board, lastSquareIdx) {\n  /**\n   * Returns the name of the winner HUMAN or AI. Else returns null.\n   */\n  // Check horizontal\n  var frontOfCurrRowIdx = lastSquareIdx - lastSquareIdx % 7;\n  var currRowIdx = frontOfCurrRowIdx;\n  var howManyConsecutiveCounter = 1; // always starts at 1 because each piece counts as one consecutive piece\n\n  for (currRowIdx; currRowIdx < frontOfCurrRowIdx + 7; currRowIdx++) {\n    if (howManyConsecutiveCounter === 4) {\n      return board[currRowIdx]; // winner has been found, return the winner\n    } else if (currRowIdx + 1 < frontOfCurrRowIdx + 7 && board[currRowIdx] !== null && board[currRowIdx] === board[currRowIdx + 1]) {\n      howManyConsecutiveCounter++;\n    } else {\n      // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n      howManyConsecutiveCounter = 1;\n    }\n  } // Check vertical\n\n\n  var currColIdx = lastSquareIdx % 7;\n  var outOfBoundsIdx = 42;\n  howManyConsecutiveCounter = 1; // always starts at 1 because each piece counts as one consecutive piece\n\n  for (currColIdx; currColIdx < outOfBoundsIdx; currColIdx += 7) {\n    if (howManyConsecutiveCounter === 4) {\n      return board[currColIdx]; // winner has been found, return the winner\n    } else if (currColIdx + 7 < outOfBoundsIdx && board[currColIdx] !== null && board[currColIdx] === board[currColIdx + 7]) {\n      howManyConsecutiveCounter++;\n    } else {\n      // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n      howManyConsecutiveCounter = 1;\n    }\n  } // Check Diagonal\n  // start with BOTTOM-LEFT TO TOP-RIGHT relative to the lastSquareIdx\n  // get bottom left squares as indices\n\n\n  var rightColumnIdx = new Set([6, 13, 20, 27, 34, 41]);\n  var leftColumnIdx = new Set([0, 7, 14, 21, 28, 35]);\n  var bottomLeftTopRightIdx = [];\n  var i = 1;\n\n  while (lastSquareIdx - 7 * i >= 0) {\n    if (lastSquareIdx - 7 * i - i >= 0 && !rightColumnIdx.has(lastSquareIdx - 7 * i - i)) {\n      bottomLeftTopRightIdx.unshift(lastSquareIdx - 7 * i - i);\n      i++;\n    } else {\n      break;\n    }\n  } // push the selectedSquareIdx into the bottomLeftTopRightIdx array\n\n\n  bottomLeftTopRightIdx.push(lastSquareIdx); // get the top right squares as indices\n\n  i = 1;\n\n  while (lastSquareIdx + 7 * i < 42) {\n    if (lastSquareIdx + 7 * i + i < 42 && !leftColumnIdx.has(lastSquareIdx + 7 * i + i)) {\n      bottomLeftTopRightIdx.push(lastSquareIdx + 7 * i + i);\n      i++;\n    } else {\n      break;\n    }\n  } // check to see if there is a 4-in-a-row from bottom left to top right\n\n\n  howManyConsecutiveCounter = 1;\n\n  for (var _i = 0; _i < bottomLeftTopRightIdx.length; _i++) {\n    if (howManyConsecutiveCounter === 4) {\n      return board[bottomLeftTopRightIdx[_i]]; // winner has been found, return the winner\n    } else if (board[bottomLeftTopRightIdx[_i]] !== null && board[bottomLeftTopRightIdx[_i]] === board[bottomLeftTopRightIdx[_i + 1]]) {\n      howManyConsecutiveCounter++;\n    } else {\n      // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n      howManyConsecutiveCounter = 1;\n    }\n  } // NOW DO THE OTHER DIAGONAL... BOTTOM-RIGHT TO TOP-LEFT relative to the lastSquareIdx\n  // get bottom right squares as indices\n\n\n  var bottomRightTopLeftIdx = [];\n  i = 1;\n\n  while (lastSquareIdx - 7 * i >= 0) {\n    if (!leftColumnIdx.has(lastSquareIdx - 7 * i + i)) {\n      bottomRightTopLeftIdx.unshift(lastSquareIdx - 7 * i + i);\n      i++;\n    } else {\n      break;\n    }\n  } // push the selectedSquareIdx into the bottomRightTopLeftIdx array\n\n\n  bottomRightTopLeftIdx.push(lastSquareIdx); // get the top left squares as indices\n\n  i = 1;\n\n  while (lastSquareIdx + 7 * i < 42) {\n    if (!rightColumnIdx.has(lastSquareIdx + 7 * i - i)) {\n      bottomRightTopLeftIdx.push(lastSquareIdx + 7 * i - i);\n      i++;\n    } else {\n      break;\n    }\n  } // check to see if there is a 4-in-a-row from bottom right to top left\n\n\n  howManyConsecutiveCounter = 1;\n\n  for (var _i2 = 0; _i2 < bottomRightTopLeftIdx.length; _i2++) {\n    if (howManyConsecutiveCounter === 4) {\n      return board[bottomRightTopLeftIdx[_i2]]; // winner has been found, return the winner\n    } else if (board[bottomRightTopLeftIdx[_i2]] !== null && board[bottomRightTopLeftIdx[_i2]] === board[bottomRightTopLeftIdx[_i2 + 1]]) {\n      howManyConsecutiveCounter++;\n    } else {\n      // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n      howManyConsecutiveCounter = 1;\n    }\n  }\n\n  return null;\n}\n\nfunction minimax(board, depth, maximizingPlayer) {\n  /**\n   * minimax algorithm to determine how the ai will make its move\n   * refer to the pseudocode on wikipedia\n   */\n  if (depth == 0 || null) {\n    return;\n  }\n}\n\nexport default minimax;","map":{"version":3,"sources":["/Users/kevintsai/Desktop/resume_website/components/portfolio/connect4/minimax.js"],"names":["calculateScoreForMove","board","player","idx","score","WINDOWLENGTH","frontOfRowIdx","rowArr","slice","frontIdx","cutOffIdx","windowArr","filter","val","length","calculateScoreHorizontal","calculateWinner","lastSquareIdx","frontOfCurrRowIdx","currRowIdx","howManyConsecutiveCounter","currColIdx","outOfBoundsIdx","rightColumnIdx","Set","leftColumnIdx","bottomLeftTopRightIdx","i","has","unshift","push","bottomRightTopLeftIdx","minimax","depth","maximizingPlayer"],"mappings":"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","sourcesContent":["function calculateScoreForMove(board, player, idx) {\n    /**\n     * Returns the score for placing player's piece onto the board whose location is idx.\n     */\n\n    let score = 0;\n    const WINDOWLENGTH = 4;\n\n    // Score for horizontal\n    const frontOfRowIdx = idx - (idx % 7);\n    let rowArr = board.slice(frontOfRowIdx, frontOfRowIdx + 7);\n    for (let frontIdx = 0; cutOffIdx < WINDOWLENGTH; cutOffIdx++) {\n        const windowArr = rowArr.slice(frontIdx, frontIdx + WINDOWLENGTH);\n        if (windowArr.filter(val => val === player).length === 4) {\n            score += 100;\n        } else if (windowArr.filter(val => val === player).length === 3 && windowArr.filter(val => val === null).length === 1) {\n            score += 5;\n        }\n    }\n    \n    score += calculateScoreHorizontal(board, idx)\n}\n\nfunction calculateWinner(board, lastSquareIdx) {\n    /**\n     * Returns the name of the winner HUMAN or AI. Else returns null.\n     */\n\n    // Check horizontal\n    const frontOfCurrRowIdx = lastSquareIdx - (lastSquareIdx % 7);\n    let currRowIdx = frontOfCurrRowIdx;\n    let howManyConsecutiveCounter = 1; // always starts at 1 because each piece counts as one consecutive piece\n    for (currRowIdx; currRowIdx < frontOfCurrRowIdx + 7; currRowIdx++) {\n        if (howManyConsecutiveCounter === 4) {\n            return board[currRowIdx]; // winner has been found, return the winner\n        } else if (currRowIdx + 1 < frontOfCurrRowIdx + 7 && board[currRowIdx] !== null && board[currRowIdx] === board[currRowIdx + 1]) {\n            howManyConsecutiveCounter++;\n        } else {\n            // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n            howManyConsecutiveCounter = 1;\n        }\n    }\n\n    // Check vertical\n    let currColIdx = lastSquareIdx % 7;\n    const outOfBoundsIdx = 42;\n    howManyConsecutiveCounter = 1; // always starts at 1 because each piece counts as one consecutive piece\n    for (currColIdx; currColIdx < outOfBoundsIdx ; currColIdx += 7) {\n        if (howManyConsecutiveCounter === 4) {\n            return board[currColIdx]; // winner has been found, return the winner\n        } else if (currColIdx + 7 < outOfBoundsIdx && board[currColIdx] !== null && board[currColIdx] === board[currColIdx + 7]) {\n            howManyConsecutiveCounter++;\n        } else {\n            // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n            howManyConsecutiveCounter = 1;\n        }\n    }\n\n    // Check Diagonal\n\n    // start with BOTTOM-LEFT TO TOP-RIGHT relative to the lastSquareIdx\n    // get bottom left squares as indices\n    const rightColumnIdx = new Set([6, 13, 20, 27, 34, 41]);\n    const leftColumnIdx = new Set([0, 7, 14, 21, 28, 35]);\n    const bottomLeftTopRightIdx = [];\n    let i = 1;\n    while (lastSquareIdx - 7 * i >= 0) {\n        if (lastSquareIdx - 7 * i - i >= 0 && !rightColumnIdx.has(lastSquareIdx - 7 * i - i)) {\n            bottomLeftTopRightIdx.unshift(lastSquareIdx - 7 * i - i);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    // push the selectedSquareIdx into the bottomLeftTopRightIdx array\n    bottomLeftTopRightIdx.push(lastSquareIdx);\n\n    // get the top right squares as indices\n    i = 1;\n    while (lastSquareIdx + 7 * i < 42) {\n        if (lastSquareIdx + 7 * i + i < 42 && !leftColumnIdx.has(lastSquareIdx + 7 * i + i)) {\n            bottomLeftTopRightIdx.push(lastSquareIdx + 7 * i + i);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    // check to see if there is a 4-in-a-row from bottom left to top right\n    howManyConsecutiveCounter = 1;\n    for (let i = 0; i < bottomLeftTopRightIdx.length; i++) {\n        if (howManyConsecutiveCounter === 4) {\n            return board[bottomLeftTopRightIdx[i]]; // winner has been found, return the winner\n        } else if (board[bottomLeftTopRightIdx[i]] !== null && board[bottomLeftTopRightIdx[i]] === board[bottomLeftTopRightIdx[i + 1]]) {\n            howManyConsecutiveCounter++;\n        } else {\n            // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n            howManyConsecutiveCounter = 1;\n        }\n    }\n\n    // NOW DO THE OTHER DIAGONAL... BOTTOM-RIGHT TO TOP-LEFT relative to the lastSquareIdx\n    // get bottom right squares as indices\n    const bottomRightTopLeftIdx = [];\n    i = 1;\n    while (lastSquareIdx - 7 * i >= 0) {\n        if (!leftColumnIdx.has(lastSquareIdx - 7 * i + i)) {\n            bottomRightTopLeftIdx.unshift(lastSquareIdx - 7 * i + i);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    // push the selectedSquareIdx into the bottomRightTopLeftIdx array\n    bottomRightTopLeftIdx.push(lastSquareIdx);\n\n    // get the top left squares as indices\n    i = 1;\n    while (lastSquareIdx + 7 * i < 42) {\n        if (!rightColumnIdx.has(lastSquareIdx + 7 * i - i)) {\n            bottomRightTopLeftIdx.push(lastSquareIdx + 7 * i - i);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    // check to see if there is a 4-in-a-row from bottom right to top left\n    howManyConsecutiveCounter = 1;\n    for (let i = 0; i < bottomRightTopLeftIdx.length; i++) {\n        if (howManyConsecutiveCounter === 4) {\n            return board[bottomRightTopLeftIdx[i]]; // winner has been found, return the winner\n        } else if (board[bottomRightTopLeftIdx[i]] !== null && board[bottomRightTopLeftIdx[i]] === board[bottomRightTopLeftIdx[i + 1]]) {\n            howManyConsecutiveCounter++;\n        } else {\n            // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n            howManyConsecutiveCounter = 1;\n        }\n    }\n\n    return null;\n}\n\nfunction minimax(board, depth, maximizingPlayer) {\n    /**\n     * minimax algorithm to determine how the ai will make its move\n     * refer to the pseudocode on wikipedia\n     */\n\n     if (depth == 0 || null) {\n         return;\n     }\n}\n\nexport default minimax;"]},"metadata":{},"sourceType":"module"}