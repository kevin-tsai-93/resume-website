{"ast":null,"code":"import deepCopy2DArray from './deepCopy2DArray';\nexport default function minimax(board, depth, isMaximizingPlayer, maximizingPlayer, minimizingPlayer) {\n  /**\n   * minimax algorithm to determine how and where the ai will make its move\n   * refer to the pseudocode on wikipedia\n   * it will return the optimal rowIdx and colIdx, the location to place the piece onto the board\n   * return value looks like [optimalRowIdx, optimalColIdx]\n   * \n   * board is a row x col array\n   * depth tells you how far down the tree you will traverse to find the calculated score\n   * maximizingPlayer is the player that is trying to win... in this case the AI = \"ai\"\n   * minimizingPlayer is the player that is trying to prevent the maximizingPlayer from winning... in this case HUMAN = \"you\"\n   */\n  var TOTALNUMOFROWS = board.length; // might not need this here\n\n  var TOTALNUMOFCOLUMNS = board[0].length; // get all the possible moves that the player can drop onto the board\n  // will have 2 arrays: column index array and row index array\n  // refer to the note below about the relationship between these two arrays\n\n  var columnIndicesOfBoard = []; // this will look like [0,1,2,3,4,5,6]\n\n  for (var i = 0; i < TOTALNUMOFCOLUMNS; i++) {\n    columnIndicesOfBoard.push(i);\n  } // note that possibleRowIndicesToPlacePieceOntoBoard is relative to columnIndicesOfBoard\n  // i.e. columnIndicesOfBoard = [0,1,2,3,4,5,6]\n  // i.e. possibleRowIndicesToPlacePieceOntoBoard = [3,3,4,2,1,2,1]\n  // this means board[3][0]... board[3][1]... board[4][2]... board[2][3]... board[1][4]... etc are pieces that can be placed onto the board\n\n\n  var possibleRowIndicesToPlacePieceOntoBoard = columnIndicesOfBoard.map(function (colIdx) {\n    return findLegalRowIdxWithinColumn(board, colIdx);\n  }); // note that possibleRowIndicesToPlacePieceOntoBoard might have -1 values\n\n  var maxScore = null;\n  var optimalRowIdx;\n  var optimalColIdx;\n  var scoresForPossibleMovesArr = []; // delete this later\n\n  for (var _i = 0; _i < columnIndicesOfBoard.length; _i++) {\n    if (possibleRowIndicesToPlacePieceOntoBoard[_i] !== -1) {\n      var rowIdx = possibleRowIndicesToPlacePieceOntoBoard[_i];\n      var colIdx = columnIndicesOfBoard[_i];\n      var calculatedScore = calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer);\n      scoresForPossibleMovesArr.push(calculatedScore); // delete this later\n\n      if (maxScore === null || calculatedScore >= maxScore) {\n        maxScore = calculatedScore;\n        optimalRowIdx = rowIdx;\n        optimalColIdx = colIdx;\n      }\n    }\n  }\n\n  alert(scoresForPossibleMovesArr); // delete this later\n\n  return [optimalRowIdx, optimalColIdx];\n}\n\nfunction isGameOver(board, maximizingPlayer, minimizingPlayer) {\n  if (isWinner(board, maximizingPlayer)) {\n    return true;\n  } else if (isWinner(board, minimizingPlayer)) {\n    return true;\n  } else if (isBoardAllFilled(board)) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction isWinner(board, player) {\n  var WINDOW = 4; // check horizontal\n\n  for (var rowIdx = 0; rowIdx < board.length; rowIdx++) {\n    for (var colIdx = 0; colIdx + WINDOW <= board[0].length; colIdx++) {\n      var fourHorizontalAdjacentSquares = board[rowIdx].slice(colIdx, colIdx + WINDOW);\n\n      if (fourHorizontalAdjacentSquares.every(function (val) {\n        return val === player;\n      })) {\n        return true;\n      }\n    }\n  } // Check vertical\n\n\n  for (var _colIdx = 0; _colIdx < board[0].length; _colIdx++) {\n    for (var _rowIdx = 0; _rowIdx + WINDOW <= board.length; _rowIdx++) {\n      var matchingPlayerCounter = 0;\n\n      for (var offset = 0; offset < WINDOW; offset++) {\n        if (board[_rowIdx + offset][_colIdx] === player) {\n          matchingPlayerCounter++;\n        }\n\n        if (matchingPlayerCounter === WINDOW) {\n          return true;\n        }\n      }\n    }\n  } // Check diagonals\n  // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n    var aDiagonalOfSquaresArr = [];\n\n    for (var runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n      aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n    }\n\n    for (var _offset = 0; _offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; _offset++) {\n      var diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(_offset, _offset + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx = Math.floor(TOTALNUMOFROWS / 2); _currRowIdx < TOTALNUMOFROWS; _currRowIdx++) {\n    var _aDiagonalOfSquaresArr = [];\n\n    for (var _runningRowIdx = _currRowIdx, _runningColIdx = TOTALNUMOFCOLUMNS - 1; _runningRowIdx >= 0 && _runningColIdx > 0; _runningRowIdx--, _runningColIdx--) {\n      _aDiagonalOfSquaresArr.push(newBoard[_runningRowIdx][_runningColIdx]);\n    }\n\n    for (var _offset2 = 0; _offset2 + WINDOWLENGTH <= _aDiagonalOfSquaresArr.length; _offset2++) {\n      var _diagonalFourAdjacentSquares = _aDiagonalOfSquaresArr.slice(_offset2, _offset2 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx2 = Math.floor(TOTALNUMOFROWS / 2); _currRowIdx2 < TOTALNUMOFROWS; _currRowIdx2++) {\n    var _aDiagonalOfSquaresArr2 = [];\n\n    for (var _runningRowIdx2 = _currRowIdx2, _runningColIdx2 = 0; _runningRowIdx2 >= 0 && _runningColIdx2 < TOTALNUMOFCOLUMNS; _runningRowIdx2--, _runningColIdx2++) {\n      _aDiagonalOfSquaresArr2.push(newBoard[_runningRowIdx2][_runningColIdx2]);\n    }\n\n    for (var _offset3 = 0; _offset3 + WINDOWLENGTH <= _aDiagonalOfSquaresArr2.length; _offset3++) {\n      var _diagonalFourAdjacentSquares2 = _aDiagonalOfSquaresArr2.slice(_offset3, _offset3 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares2, maximizingPlayer, minimizingPlayer);\n    }\n  } // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx3 = Math.floor(TOTALNUMOFROWS / 2) - 1; _currRowIdx3 >= 0; _currRowIdx3--) {\n    var _aDiagonalOfSquaresArr3 = [];\n\n    for (var _runningRowIdx3 = _currRowIdx3, _runningColIdx3 = TOTALNUMOFCOLUMNS - 1; _runningRowIdx3 < TOTALNUMOFROWS && _runningColIdx3 > 0; _runningRowIdx3++, _runningColIdx3--) {\n      _aDiagonalOfSquaresArr3.push(newBoard[_runningRowIdx3][_runningColIdx3]);\n    }\n\n    for (var _offset4 = 0; _offset4 + WINDOWLENGTH <= _aDiagonalOfSquaresArr3.length; _offset4++) {\n      var _diagonalFourAdjacentSquares3 = _aDiagonalOfSquaresArr3.slice(_offset4, _offset4 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares3, maximizingPlayer, minimizingPlayer);\n    }\n  }\n}\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n  /**\n   * Returns the row index of a legal square that can be filled given the board (2 dimensional row x col).\n   * Note the legal square will be within the same column as selectedColIdx.\n   * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n   */\n  var didNotFindLegalRowIdxWithinColumnIdx = -1;\n\n  for (var rowIdx = 0; rowIdx < board.length; rowIdx++) {\n    if (board[rowIdx][selectedColIdx] === null) {\n      return rowIdx;\n    }\n  }\n\n  return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, maximizingPlayer, minimizingPlayer) {\n  /**\n   * Returns the score for the given arr, assuming the length of the arr is 4\n   */\n  var score = 0;\n\n  if (arr.filter(function (val) {\n    return val === maximizingPlayer;\n  }).length === 4) {\n    score += 100;\n  } else if (arr.filter(function (val) {\n    return val === maximizingPlayer;\n  }).length === 3 && arr.filter(function (val) {\n    return val === null;\n  }).length === 1) {\n    score += 5;\n  } else if (arr.filter(function (val) {\n    return val === maximizingPlayer;\n  }).length === 2 && arr.filter(function (val) {\n    return val === null;\n  }).length === 2) {\n    score += 2;\n  }\n\n  if (arr.filter(function (val) {\n    return val === minimizingPlayer;\n  }).length === 3 && arr.filter(function (val) {\n    return val === null;\n  }).length === 1) {\n    score -= 15;\n  }\n\n  return score;\n}\n\nfunction calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer) {\n  /**\n   * Returns the score for placing maximizingPlayer's piece onto the board whose location is rowIdx and colIdx.\n   */\n  var score = 0;\n  var TOTALNUMOFROWS = board.length;\n  var TOTALNUMOFCOLUMNS = board[0].length;\n  var WINDOWLENGTH = 4;\n  var CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n  var newBoard = deepCopy2DArray(board);\n  newBoard[rowIdx][colIdx] = maximizingPlayer; // score for center piece (preference center location)\n\n  for (var currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n    if (newBoard[currRowIdx][CENTERCOLUMNIDX] === maximizingPlayer) {\n      score += 2;\n    }\n  } // Score for horizontal\n  // Scores are calculated for window lengths of 4\n\n\n  for (var _currRowIdx4 = 0; _currRowIdx4 < TOTALNUMOFROWS; _currRowIdx4++) {\n    for (var offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFCOLUMNS; offset++) {\n      var horizontalFourAdjacentSquares = newBoard[_currRowIdx4].slice(offset, offset + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Score for vertical\n  // Scores are calculated for window lengths of 4\n\n\n  for (var currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n    var aColumnOfSquaresArr = [];\n\n    for (var _currRowIdx5 = 0; _currRowIdx5 < TOTALNUMOFROWS; _currRowIdx5++) {\n      aColumnOfSquaresArr.push(newBoard[_currRowIdx5][currColIdx]);\n    }\n\n    for (var _offset5 = 0; _offset5 + WINDOWLENGTH <= TOTALNUMOFROWS; _offset5++) {\n      var verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(_offset5, _offset5 + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Score for diagonal\n  // Scores are calculated for window lengths of 4\n  // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx6 = Math.floor(TOTALNUMOFROWS / 2) - 1; _currRowIdx6 >= 0; _currRowIdx6--) {\n    var aDiagonalOfSquaresArr = [];\n\n    for (var runningRowIdx = _currRowIdx6, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n      aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n    }\n\n    for (var _offset6 = 0; _offset6 + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; _offset6++) {\n      var diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(_offset6, _offset6 + WINDOWLENGTH);\n      score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n    }\n  } // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx7 = Math.floor(TOTALNUMOFROWS / 2); _currRowIdx7 < TOTALNUMOFROWS; _currRowIdx7++) {\n    var _aDiagonalOfSquaresArr4 = [];\n\n    for (var _runningRowIdx4 = _currRowIdx7, _runningColIdx4 = TOTALNUMOFCOLUMNS - 1; _runningRowIdx4 >= 0 && _runningColIdx4 > 0; _runningRowIdx4--, _runningColIdx4--) {\n      _aDiagonalOfSquaresArr4.push(newBoard[_runningRowIdx4][_runningColIdx4]);\n    }\n\n    for (var _offset7 = 0; _offset7 + WINDOWLENGTH <= _aDiagonalOfSquaresArr4.length; _offset7++) {\n      var _diagonalFourAdjacentSquares4 = _aDiagonalOfSquaresArr4.slice(_offset7, _offset7 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares4, maximizingPlayer, minimizingPlayer);\n    }\n  } // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx8 = Math.floor(TOTALNUMOFROWS / 2); _currRowIdx8 < TOTALNUMOFROWS; _currRowIdx8++) {\n    var _aDiagonalOfSquaresArr5 = [];\n\n    for (var _runningRowIdx5 = _currRowIdx8, _runningColIdx5 = 0; _runningRowIdx5 >= 0 && _runningColIdx5 < TOTALNUMOFCOLUMNS; _runningRowIdx5--, _runningColIdx5++) {\n      _aDiagonalOfSquaresArr5.push(newBoard[_runningRowIdx5][_runningColIdx5]);\n    }\n\n    for (var _offset8 = 0; _offset8 + WINDOWLENGTH <= _aDiagonalOfSquaresArr5.length; _offset8++) {\n      var _diagonalFourAdjacentSquares5 = _aDiagonalOfSquaresArr5.slice(_offset8, _offset8 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares5, maximizingPlayer, minimizingPlayer);\n    }\n  } // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n\n\n  for (var _currRowIdx9 = Math.floor(TOTALNUMOFROWS / 2) - 1; _currRowIdx9 >= 0; _currRowIdx9--) {\n    var _aDiagonalOfSquaresArr6 = [];\n\n    for (var _runningRowIdx6 = _currRowIdx9, _runningColIdx6 = TOTALNUMOFCOLUMNS - 1; _runningRowIdx6 < TOTALNUMOFROWS && _runningColIdx6 > 0; _runningRowIdx6++, _runningColIdx6--) {\n      _aDiagonalOfSquaresArr6.push(newBoard[_runningRowIdx6][_runningColIdx6]);\n    }\n\n    for (var _offset9 = 0; _offset9 + WINDOWLENGTH <= _aDiagonalOfSquaresArr6.length; _offset9++) {\n      var _diagonalFourAdjacentSquares6 = _aDiagonalOfSquaresArr6.slice(_offset9, _offset9 + WINDOWLENGTH);\n\n      score += calculateScoreForThese4Squares(_diagonalFourAdjacentSquares6, maximizingPlayer, minimizingPlayer);\n    }\n  }\n\n  return score;\n}","map":{"version":3,"sources":["/Users/kevintsai/Desktop/resume_website/components/portfolio/connect4/minimax.js"],"names":["deepCopy2DArray","minimax","board","depth","isMaximizingPlayer","maximizingPlayer","minimizingPlayer","TOTALNUMOFROWS","length","TOTALNUMOFCOLUMNS","columnIndicesOfBoard","i","push","possibleRowIndicesToPlacePieceOntoBoard","map","colIdx","findLegalRowIdxWithinColumn","maxScore","optimalRowIdx","optimalColIdx","scoresForPossibleMovesArr","rowIdx","calculatedScore","calculateScoreForMove","alert","isGameOver","isWinner","isBoardAllFilled","player","WINDOW","fourHorizontalAdjacentSquares","slice","every","val","matchingPlayerCounter","offset","currRowIdx","Math","floor","aDiagonalOfSquaresArr","runningRowIdx","runningColIdx","newBoard","WINDOWLENGTH","diagonalFourAdjacentSquares","score","calculateScoreForThese4Squares","selectedColIdx","didNotFindLegalRowIdxWithinColumnIdx","arr","filter","CENTERCOLUMNIDX","horizontalFourAdjacentSquares","currColIdx","aColumnOfSquaresArr","verticalFourAdjacentSquares"],"mappings":"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","sourcesContent":["import deepCopy2DArray from './deepCopy2DArray';\n\nexport default function minimax(board, depth, isMaximizingPlayer, maximizingPlayer, minimizingPlayer) {\n    /**\n     * minimax algorithm to determine how and where the ai will make its move\n     * refer to the pseudocode on wikipedia\n     * it will return the optimal rowIdx and colIdx, the location to place the piece onto the board\n     * return value looks like [optimalRowIdx, optimalColIdx]\n     * \n     * board is a row x col array\n     * depth tells you how far down the tree you will traverse to find the calculated score\n     * maximizingPlayer is the player that is trying to win... in this case the AI = \"ai\"\n     * minimizingPlayer is the player that is trying to prevent the maximizingPlayer from winning... in this case HUMAN = \"you\"\n     */\n\n    const TOTALNUMOFROWS = board.length; // might not need this here\n    const TOTALNUMOFCOLUMNS = board[0].length;\n\n    // get all the possible moves that the player can drop onto the board\n    // will have 2 arrays: column index array and row index array\n    // refer to the note below about the relationship between these two arrays\n    const columnIndicesOfBoard = []; // this will look like [0,1,2,3,4,5,6]\n    for (let i = 0; i < TOTALNUMOFCOLUMNS; i++) {\n        columnIndicesOfBoard.push(i);\n    }\n    // note that possibleRowIndicesToPlacePieceOntoBoard is relative to columnIndicesOfBoard\n    // i.e. columnIndicesOfBoard = [0,1,2,3,4,5,6]\n    // i.e. possibleRowIndicesToPlacePieceOntoBoard = [3,3,4,2,1,2,1]\n    // this means board[3][0]... board[3][1]... board[4][2]... board[2][3]... board[1][4]... etc are pieces that can be placed onto the board\n    const possibleRowIndicesToPlacePieceOntoBoard = columnIndicesOfBoard.map(colIdx => findLegalRowIdxWithinColumn(board, colIdx)); // note that possibleRowIndicesToPlacePieceOntoBoard might have -1 values\n    let maxScore = null;\n    let optimalRowIdx;\n    let optimalColIdx;\n\n\n\n    const scoresForPossibleMovesArr = []; // delete this later\n\n    for (let i = 0; i < columnIndicesOfBoard.length; i++) {\n        if (possibleRowIndicesToPlacePieceOntoBoard[i] !== -1) {\n            let rowIdx = possibleRowIndicesToPlacePieceOntoBoard[i];\n            let colIdx = columnIndicesOfBoard[i];\n            let calculatedScore = calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer);\n            scoresForPossibleMovesArr.push(calculatedScore); // delete this later\n            if (maxScore === null || calculatedScore >= maxScore) {\n                maxScore = calculatedScore;\n                optimalRowIdx = rowIdx;\n                optimalColIdx = colIdx;\n            }\n        }\n    }\n    alert(scoresForPossibleMovesArr); // delete this later\n    return [optimalRowIdx, optimalColIdx];\n}\n\nfunction isGameOver(board, maximizingPlayer, minimizingPlayer) {\n    if (isWinner(board, maximizingPlayer)) {\n        return true;\n    } else if (isWinner(board, minimizingPlayer)) {\n        return true;\n    } else if (isBoardAllFilled(board)) {\n        return true;\n    } else {\n        return false;\n    }\n}\n\nfunction isWinner(board, player) {\n    const WINDOW = 4;\n\n    // check horizontal\n    for (let rowIdx = 0; rowIdx < board.length; rowIdx++) {\n        for (let colIdx = 0; colIdx + WINDOW <= board[0].length; colIdx++) {\n            const fourHorizontalAdjacentSquares = board[rowIdx].slice(colIdx, colIdx + WINDOW);\n            if (fourHorizontalAdjacentSquares.every(val => val === player)) {\n                return true;\n            }\n        }       \n    }\n\n    // Check vertical\n    for (let colIdx = 0; colIdx < board[0].length; colIdx++) {\n        for (let rowIdx = 0; rowIdx + WINDOW <= board.length; rowIdx++) {\n            let matchingPlayerCounter = 0;\n            for (let offset = 0; offset < WINDOW; offset++) {\n                if (board[rowIdx + offset][colIdx] === player) {\n                    matchingPlayerCounter++;\n                }\n                if (matchingPlayerCounter === WINDOW) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    // Check diagonals\n\n        // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n        for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n            const aDiagonalOfSquaresArr = [];\n            for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n                aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n            }\n            for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n                const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n                score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n            }\n        }\n    \n        // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n        for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n            const aDiagonalOfSquaresArr = [];\n            for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx >= 0 && runningColIdx > 0; runningRowIdx--, runningColIdx--) {\n                aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n            }\n            for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n                const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n                score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n            }\n        }\n    \n        // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n        for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n            const aDiagonalOfSquaresArr = [];\n            for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx >= 0 && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx--, runningColIdx++) {\n                aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n            }\n            for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n                const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n                score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n            }\n        }\n    \n        // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n        for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n            const aDiagonalOfSquaresArr = [];\n            for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx < TOTALNUMOFROWS && runningColIdx > 0; runningRowIdx++, runningColIdx--) {\n                aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n            }\n            for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n                const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n                score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n            }\n        }\n\n}\n\nfunction findLegalRowIdxWithinColumn(board, selectedColIdx) {\n    /**\n     * Returns the row index of a legal square that can be filled given the board (2 dimensional row x col).\n     * Note the legal square will be within the same column as selectedColIdx.\n     * If all the squares within selectedColIdx's column are filled, then this function returns -1.\n     */\n    const didNotFindLegalRowIdxWithinColumnIdx = -1;\n    for (let rowIdx = 0; rowIdx < board.length; rowIdx++) {\n        if (board[rowIdx][selectedColIdx] === null) {\n            return rowIdx;\n        }\n    }\n    return didNotFindLegalRowIdxWithinColumnIdx;\n}\n\nfunction calculateScoreForThese4Squares(arr, maximizingPlayer, minimizingPlayer) {\n    /**\n     * Returns the score for the given arr, assuming the length of the arr is 4\n     */\n\n    let score = 0;\n\n    if (arr.filter(val => val === maximizingPlayer).length === 4) {\n        score += 100;\n    } else if (arr.filter(val => val === maximizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score += 5;\n    } else if (arr.filter(val => val === maximizingPlayer).length === 2 && arr.filter(val => val === null).length === 2) {\n        score += 2;\n    }\n\n    if (arr.filter(val => val === minimizingPlayer).length === 3 && arr.filter(val => val === null).length === 1) {\n        score -= 15;\n    }\n\n    return score;\n}\n\nfunction calculateScoreForMove(rowIdx, colIdx, board, maximizingPlayer, minimizingPlayer) {\n    /**\n     * Returns the score for placing maximizingPlayer's piece onto the board whose location is rowIdx and colIdx.\n     */\n\n    let score = 0;\n\n    const TOTALNUMOFROWS = board.length;\n    const TOTALNUMOFCOLUMNS = board[0].length;\n    const WINDOWLENGTH = 4;\n    const CENTERCOLUMNIDX = Math.floor(TOTALNUMOFCOLUMNS / 2);\n\n    const newBoard = deepCopy2DArray(board);\n    newBoard[rowIdx][colIdx] = maximizingPlayer;\n\n    // score for center piece (preference center location)\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        if (newBoard[currRowIdx][CENTERCOLUMNIDX] === maximizingPlayer) {\n            score += 2;\n        }\n    }\n\n\n    // Score for horizontal\n    // Scores are calculated for window lengths of 4\n    for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFCOLUMNS; offset++) {\n            const horizontalFourAdjacentSquares = newBoard[currRowIdx].slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(horizontalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Score for vertical\n    // Scores are calculated for window lengths of 4\n    for (let currColIdx = 0; currColIdx < TOTALNUMOFCOLUMNS; currColIdx++) {\n        const aColumnOfSquaresArr = [];\n        for (let currRowIdx = 0; currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n            aColumnOfSquaresArr.push(newBoard[currRowIdx][currColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= TOTALNUMOFROWS; offset++) {\n            const verticalFourAdjacentSquares = aColumnOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(verticalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Score for diagonal\n    // Scores are calculated for window lengths of 4\n\n    // Calculate score for positive sloping diagonal (bottom-left to top-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx < TOTALNUMOFROWS && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx++, runningColIdx++) {\n            aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Continue calculating the score for positive sloping diagonal (bottom-left to top-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx >= 0 && runningColIdx > 0; runningRowIdx--, runningColIdx--) {\n            aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Calculate score for negative sloping diagonal (top-left to bottom-right FOR THE LEFT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2); currRowIdx < TOTALNUMOFROWS; currRowIdx++) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = 0; runningRowIdx >= 0 && runningColIdx < TOTALNUMOFCOLUMNS; runningRowIdx--, runningColIdx++) {\n            aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    // Continue calculating the score for negative sloping diagonal (top-left to bottom-right FOR THE RIGHT HALF OF THE BOARD)\n    for (let currRowIdx = Math.floor(TOTALNUMOFROWS / 2) - 1; currRowIdx >= 0; currRowIdx--) {\n        const aDiagonalOfSquaresArr = [];\n        for (let runningRowIdx = currRowIdx, runningColIdx = TOTALNUMOFCOLUMNS - 1; runningRowIdx < TOTALNUMOFROWS && runningColIdx > 0; runningRowIdx++, runningColIdx--) {\n            aDiagonalOfSquaresArr.push(newBoard[runningRowIdx][runningColIdx]);\n        }\n        for (let offset = 0; offset + WINDOWLENGTH <= aDiagonalOfSquaresArr.length; offset++) {\n            const diagonalFourAdjacentSquares = aDiagonalOfSquaresArr.slice(offset, offset + WINDOWLENGTH);\n            score += calculateScoreForThese4Squares(diagonalFourAdjacentSquares, maximizingPlayer, minimizingPlayer);\n        }\n    }\n\n    return score;\n}"]},"metadata":{},"sourceType":"module"}