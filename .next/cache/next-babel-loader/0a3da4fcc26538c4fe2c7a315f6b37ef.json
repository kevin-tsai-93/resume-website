{"ast":null,"code":"function findLegalSquare(board, idx) {\n  /**\n   * Returns the index of a legal square that can be filled.\n   * Note the legal square will be within the same column as idx.\n   * If all the squares within idx's column are filled, then this function returns -1.\n   */\n  var didNotFindLegalSquareIdx = -1;\n  var traversingIdx = idx;\n\n  while (traversingIdx - 7 >= 0) {\n    traversingIdx -= 7;\n  }\n\n  for (traversingIdx; traversingIdx < 42; traversingIdx += 7) {\n    if (board[traversingIdx] === null) {\n      return traversingIdx;\n    }\n  }\n\n  return didNotFindLegalSquareIdx;\n}\n\nfunction calculateScoreForWindow(windowArr, player, opposingPlayer) {\n  /**\n   * Returns the score for a given arr, assuming the window is 4\n   */\n  var score = 0;\n\n  if (windowArr.filter(function (val) {\n    return val === player;\n  }).length === 4) {\n    score += 100;\n  } else if (windowArr.filter(function (val) {\n    return val === player;\n  }).length === 3 && windowArr.filter(function (val) {\n    return val === null;\n  }).length === 1) {\n    score += 5;\n  } else if (windowArr.filter(function (val) {\n    return val === player;\n  }).length === 2 && windowArr.filter(function (val) {\n    return val === null;\n  }).length === 2) {\n    score += 2;\n  }\n\n  if (windowArr.filter(function (val) {\n    return val === opposingPlayer;\n  }).length === 3 && windowArr.filter(function (val) {\n    return val === null;\n  }).length === 1) {\n    score += 8;\n  }\n\n  return score;\n}\n\nfunction calculateScoreForMove(board, idx, player, opposingPlayer) {\n  /**\n   * Returns the score for placing player's piece onto the board whose location is idx.\n   */\n  var score = 0;\n  var WINDOWLENGTH = 4; // score for center piece (preference center location)\n\n  if (idx % 7 === 3) {\n    // idx is in the center location\n    var frontOfCenterColIdx = idx % 7;\n    var _colArr = [];\n\n    for (var i = frontOfCenterColIdx; i < 42; i += 7) {\n      if (idx !== i) {\n        _colArr.push(board[i]);\n      } else {\n        // put the player's piece onto the new board\n        _colArr.push(player);\n      }\n    }\n\n    score += _colArr.filter(function (val) {\n      return val === player;\n    }).length * 2;\n  } // Score for horizontal\n\n\n  var frontOfRowIdx = idx - idx % 7;\n  var rowArr = board.slice(frontOfRowIdx, frontOfRowIdx + 7);\n  rowArr[idx % 7] = player;\n\n  for (var frontIdx = 0; frontIdx < WINDOWLENGTH; frontIdx++) {\n    var windowArr = rowArr.slice(frontIdx, frontIdx + WINDOWLENGTH);\n\n    if (frontIdx <= idx % 7 && idx % 7 < frontIdx + WINDOWLENGTH) {\n      score += calculateScoreForWindow(windowArr, player, opposingPlayer);\n    }\n  } // Score for vertical\n\n\n  var frontOfColIdx = idx % 7;\n  var colArr = [];\n  var playerOnColArrIdx;\n\n  for (var _i = frontOfColIdx; _i < 42; _i += 7) {\n    if (idx !== _i) {\n      colArr.push(board[_i]);\n    } else {\n      // put the player's piece onto the new board if idx === i\n      colArr.push(player);\n      playerOnColArrIdx = colArr.length - 1;\n    }\n  }\n\n  for (var _frontIdx = 0; _frontIdx < WINDOWLENGTH; _frontIdx++) {\n    var _windowArr = colArr.slice(_frontIdx, _frontIdx + WINDOWLENGTH);\n\n    if (_frontIdx <= playerOnColArrIdx && playerOnColArrIdx < _frontIdx + WINDOWLENGTH) {\n      score += calculateScoreForWindow(_windowArr, player, opposingPlayer);\n    }\n  } // // Score for diagonal\n  // // start with BOTTOM-LEFT TO TOP-RIGHT relative to the lastSquareIdx\n  // // get bottom left squares as indices\n  // const rightColumnIdx = new Set([6, 13, 20, 27, 34, 41]);\n  // const leftColumnIdx = new Set([0, 7, 14, 21, 28, 35]);\n  // const bottomLeftTopRightIdx = [];\n  // let i = 1;\n  // while (lastSquareIdx - 7 * i >= 0) {\n  //     if (lastSquareIdx - 7 * i - i >= 0 && !rightColumnIdx.has(lastSquareIdx - 7 * i - i)) {\n  //         bottomLeftTopRightIdx.unshift(lastSquareIdx - 7 * i - i);\n  //         i++;\n  //     } else {\n  //         break;\n  //     }\n  // }\n  // // push the selectedSquareIdx into the bottomLeftTopRightIdx array\n  // bottomLeftTopRightIdx.push(lastSquareIdx);\n  // // get the top right squares as indices\n  // i = 1;\n  // while (lastSquareIdx + 7 * i < 42) {\n  //     if (lastSquareIdx + 7 * i + i < 42 && !leftColumnIdx.has(lastSquareIdx + 7 * i + i)) {\n  //         bottomLeftTopRightIdx.push(lastSquareIdx + 7 * i + i);\n  //         i++;\n  //     } else {\n  //         break;\n  //     }\n  // }\n\n\n  return score;\n}\n\nfunction calculateWinner(board, lastSquareIdx) {\n  /**\n   * Returns the name of the winner HUMAN or AI. Else returns null.\n   */\n  // Check horizontal\n  var frontOfCurrRowIdx = lastSquareIdx - lastSquareIdx % 7;\n  var currRowIdx = frontOfCurrRowIdx;\n  var howManyConsecutiveCounter = 1; // always starts at 1 because each piece counts as one consecutive piece\n\n  for (currRowIdx; currRowIdx < frontOfCurrRowIdx + 7; currRowIdx++) {\n    if (howManyConsecutiveCounter === 4) {\n      return board[currRowIdx]; // winner has been found, return the winner\n    } else if (currRowIdx + 1 < frontOfCurrRowIdx + 7 && board[currRowIdx] !== null && board[currRowIdx] === board[currRowIdx + 1]) {\n      howManyConsecutiveCounter++;\n    } else {\n      // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n      howManyConsecutiveCounter = 1;\n    }\n  } // Check vertical\n\n\n  var currColIdx = lastSquareIdx % 7;\n  var outOfBoundsIdx = 42;\n  howManyConsecutiveCounter = 1; // always starts at 1 because each piece counts as one consecutive piece\n\n  for (currColIdx; currColIdx < outOfBoundsIdx; currColIdx += 7) {\n    if (howManyConsecutiveCounter === 4) {\n      return board[currColIdx]; // winner has been found, return the winner\n    } else if (currColIdx + 7 < outOfBoundsIdx && board[currColIdx] !== null && board[currColIdx] === board[currColIdx + 7]) {\n      howManyConsecutiveCounter++;\n    } else {\n      // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n      howManyConsecutiveCounter = 1;\n    }\n  } // Check Diagonal\n  // start with BOTTOM-LEFT TO TOP-RIGHT relative to the lastSquareIdx\n  // get bottom left squares as indices\n\n\n  var rightColumnIdx = new Set([6, 13, 20, 27, 34, 41]);\n  var leftColumnIdx = new Set([0, 7, 14, 21, 28, 35]);\n  var bottomLeftTopRightIdx = [];\n  var i = 1;\n\n  while (lastSquareIdx - 7 * i >= 0) {\n    if (lastSquareIdx - 7 * i - i >= 0 && !rightColumnIdx.has(lastSquareIdx - 7 * i - i)) {\n      bottomLeftTopRightIdx.unshift(lastSquareIdx - 7 * i - i);\n      i++;\n    } else {\n      break;\n    }\n  } // push the selectedSquareIdx into the bottomLeftTopRightIdx array\n\n\n  bottomLeftTopRightIdx.push(lastSquareIdx); // get the top right squares as indices\n\n  i = 1;\n\n  while (lastSquareIdx + 7 * i < 42) {\n    if (lastSquareIdx + 7 * i + i < 42 && !leftColumnIdx.has(lastSquareIdx + 7 * i + i)) {\n      bottomLeftTopRightIdx.push(lastSquareIdx + 7 * i + i);\n      i++;\n    } else {\n      break;\n    }\n  } // check to see if there is a 4-in-a-row from bottom left to top right\n\n\n  howManyConsecutiveCounter = 1;\n\n  for (var _i2 = 0; _i2 < bottomLeftTopRightIdx.length; _i2++) {\n    if (howManyConsecutiveCounter === 4) {\n      return board[bottomLeftTopRightIdx[_i2]]; // winner has been found, return the winner\n    } else if (board[bottomLeftTopRightIdx[_i2]] !== null && board[bottomLeftTopRightIdx[_i2]] === board[bottomLeftTopRightIdx[_i2 + 1]]) {\n      howManyConsecutiveCounter++;\n    } else {\n      // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n      howManyConsecutiveCounter = 1;\n    }\n  } // NOW DO THE OTHER DIAGONAL... BOTTOM-RIGHT TO TOP-LEFT relative to the lastSquareIdx\n  // get bottom right squares as indices\n\n\n  var bottomRightTopLeftIdx = [];\n  i = 1;\n\n  while (lastSquareIdx - 7 * i >= 0) {\n    if (!leftColumnIdx.has(lastSquareIdx - 7 * i + i)) {\n      bottomRightTopLeftIdx.unshift(lastSquareIdx - 7 * i + i);\n      i++;\n    } else {\n      break;\n    }\n  } // push the selectedSquareIdx into the bottomRightTopLeftIdx array\n\n\n  bottomRightTopLeftIdx.push(lastSquareIdx); // get the top left squares as indices\n\n  i = 1;\n\n  while (lastSquareIdx + 7 * i < 42) {\n    if (!rightColumnIdx.has(lastSquareIdx + 7 * i - i)) {\n      bottomRightTopLeftIdx.push(lastSquareIdx + 7 * i - i);\n      i++;\n    } else {\n      break;\n    }\n  } // check to see if there is a 4-in-a-row from bottom right to top left\n\n\n  howManyConsecutiveCounter = 1;\n\n  for (var _i3 = 0; _i3 < bottomRightTopLeftIdx.length; _i3++) {\n    if (howManyConsecutiveCounter === 4) {\n      return board[bottomRightTopLeftIdx[_i3]]; // winner has been found, return the winner\n    } else if (board[bottomRightTopLeftIdx[_i3]] !== null && board[bottomRightTopLeftIdx[_i3]] === board[bottomRightTopLeftIdx[_i3 + 1]]) {\n      howManyConsecutiveCounter++;\n    } else {\n      // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n      howManyConsecutiveCounter = 1;\n    }\n  }\n\n  return null;\n}\n\nfunction idxOfMaxOfArr(arr) {\n  var max = arr[0];\n  var maxIdx = 0;\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i] > max) {\n      max = arr[i];\n      maxIdx = i;\n    }\n  }\n\n  return maxIdx;\n}\n\nfunction minimax(board, depth, maximizingPlayer, minimizingPlayer) {\n  /**\n   * minimax algorithm to determine how the ai will make its move\n   * refer to the pseudocode on wikipedia\n   */\n  // get all the possible moves that the player can drop into\n  // this should be an array with the indices\n  var possibleMovesArr = [0, 1, 2, 3, 4, 5, 6].map(function (idx) {\n    return findLegalSquare(board, idx);\n  }).filter(function (idx) {\n    return idx !== -1;\n  });\n  var scoresForPossibleMovesArr = possibleMovesArr.map(function (idx) {\n    return calculateScoreForMove(board, idx, maximizingPlayer, minimizingPlayer);\n  });\n  alert(scoresForPossibleMovesArr);\n  return possibleMovesArr[idxOfMaxOfArr(scoresForPossibleMovesArr)];\n}\n\nexport default minimax;","map":{"version":3,"sources":["/Users/kevintsai/Desktop/resume_website/components/portfolio/connect4/minimax.js"],"names":["findLegalSquare","board","idx","didNotFindLegalSquareIdx","traversingIdx","calculateScoreForWindow","windowArr","player","opposingPlayer","score","filter","val","length","calculateScoreForMove","WINDOWLENGTH","frontOfCenterColIdx","colArr","i","push","frontOfRowIdx","rowArr","slice","frontIdx","frontOfColIdx","playerOnColArrIdx","calculateWinner","lastSquareIdx","frontOfCurrRowIdx","currRowIdx","howManyConsecutiveCounter","currColIdx","outOfBoundsIdx","rightColumnIdx","Set","leftColumnIdx","bottomLeftTopRightIdx","has","unshift","bottomRightTopLeftIdx","idxOfMaxOfArr","arr","max","maxIdx","minimax","depth","maximizingPlayer","minimizingPlayer","possibleMovesArr","map","scoresForPossibleMovesArr","alert"],"mappings":"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","sourcesContent":["function findLegalSquare(board, idx) {\n    /**\n     * Returns the index of a legal square that can be filled.\n     * Note the legal square will be within the same column as idx.\n     * If all the squares within idx's column are filled, then this function returns -1.\n     */\n    const didNotFindLegalSquareIdx = -1;\n    let traversingIdx = idx;\n    while (traversingIdx - 7 >= 0) {\n        traversingIdx -= 7;\n    }\n    for (traversingIdx; traversingIdx < 42; traversingIdx += 7) {\n        if (board[traversingIdx] === null) {\n            return traversingIdx;\n        }\n    }\n    return didNotFindLegalSquareIdx;\n}\n\nfunction calculateScoreForWindow(windowArr, player, opposingPlayer) {\n    /**\n     * Returns the score for a given arr, assuming the window is 4\n     */\n\n    let score = 0;\n\n    if (windowArr.filter(val => val === player).length === 4) {\n        score += 100;\n    } else if (windowArr.filter(val => val === player).length === 3 && windowArr.filter(val => val === null).length === 1) {\n        score += 5;\n    } else if (windowArr.filter(val => val === player).length === 2 && windowArr.filter(val => val === null).length === 2) {\n        score += 2;\n    }\n\n    if (windowArr.filter(val => val === opposingPlayer).length === 3 && windowArr.filter(val => val === null).length === 1) {\n        score += 8;\n    }\n\n    return score;\n}\n\nfunction calculateScoreForMove(board, idx, player, opposingPlayer) {\n    /**\n     * Returns the score for placing player's piece onto the board whose location is idx.\n     */\n\n    let score = 0;\n    const WINDOWLENGTH = 4;\n\n    // score for center piece (preference center location)\n    if (idx % 7 === 3) { // idx is in the center location\n        const frontOfCenterColIdx = idx % 7;\n        const colArr = [];\n        for (let i = frontOfCenterColIdx; i < 42; i += 7) {\n            if (idx !== i) {\n                colArr.push(board[i]);            \n            } else { // put the player's piece onto the new board\n                colArr.push(player);\n            }\n        }\n        score += colArr.filter(val => val === player).length * 2;\n    }\n\n\n    // Score for horizontal\n    const frontOfRowIdx = idx - (idx % 7);\n    const rowArr = board.slice(frontOfRowIdx, frontOfRowIdx + 7);\n    rowArr[idx % 7] = player;\n    for (let frontIdx = 0; frontIdx < WINDOWLENGTH; frontIdx++) {\n        const windowArr = rowArr.slice(frontIdx, frontIdx + WINDOWLENGTH);\n        if (frontIdx <= idx % 7 && idx % 7 < frontIdx + WINDOWLENGTH) {\n            score += calculateScoreForWindow(windowArr, player, opposingPlayer);\n        }\n    }\n\n    // Score for vertical\n    const frontOfColIdx = idx % 7;\n    const colArr = [];\n    let playerOnColArrIdx;\n    for (let i = frontOfColIdx; i < 42; i += 7) {\n        if (idx !== i) {\n            colArr.push(board[i]);            \n        } else { // put the player's piece onto the new board if idx === i\n            colArr.push(player);\n            playerOnColArrIdx = colArr.length - 1;\n        }\n    }\n    for (let frontIdx = 0; frontIdx < WINDOWLENGTH; frontIdx++) {\n        const windowArr = colArr.slice(frontIdx, frontIdx + WINDOWLENGTH);\n        if (frontIdx <= playerOnColArrIdx && playerOnColArrIdx < frontIdx + WINDOWLENGTH) {\n            score += calculateScoreForWindow(windowArr, player, opposingPlayer);\n        }\n    }\n\n    // // Score for diagonal\n\n    // // start with BOTTOM-LEFT TO TOP-RIGHT relative to the lastSquareIdx\n    // // get bottom left squares as indices\n    // const rightColumnIdx = new Set([6, 13, 20, 27, 34, 41]);\n    // const leftColumnIdx = new Set([0, 7, 14, 21, 28, 35]);\n    // const bottomLeftTopRightIdx = [];\n    // let i = 1;\n    // while (lastSquareIdx - 7 * i >= 0) {\n    //     if (lastSquareIdx - 7 * i - i >= 0 && !rightColumnIdx.has(lastSquareIdx - 7 * i - i)) {\n    //         bottomLeftTopRightIdx.unshift(lastSquareIdx - 7 * i - i);\n    //         i++;\n    //     } else {\n    //         break;\n    //     }\n    // }\n\n    // // push the selectedSquareIdx into the bottomLeftTopRightIdx array\n    // bottomLeftTopRightIdx.push(lastSquareIdx);\n\n    // // get the top right squares as indices\n    // i = 1;\n    // while (lastSquareIdx + 7 * i < 42) {\n    //     if (lastSquareIdx + 7 * i + i < 42 && !leftColumnIdx.has(lastSquareIdx + 7 * i + i)) {\n    //         bottomLeftTopRightIdx.push(lastSquareIdx + 7 * i + i);\n    //         i++;\n    //     } else {\n    //         break;\n    //     }\n    // }\n\n\n    return score;\n}\n\nfunction calculateWinner(board, lastSquareIdx) {\n    /**\n     * Returns the name of the winner HUMAN or AI. Else returns null.\n     */\n\n    // Check horizontal\n    const frontOfCurrRowIdx = lastSquareIdx - (lastSquareIdx % 7);\n    let currRowIdx = frontOfCurrRowIdx;\n    let howManyConsecutiveCounter = 1; // always starts at 1 because each piece counts as one consecutive piece\n    for (currRowIdx; currRowIdx < frontOfCurrRowIdx + 7; currRowIdx++) {\n        if (howManyConsecutiveCounter === 4) {\n            return board[currRowIdx]; // winner has been found, return the winner\n        } else if (currRowIdx + 1 < frontOfCurrRowIdx + 7 && board[currRowIdx] !== null && board[currRowIdx] === board[currRowIdx + 1]) {\n            howManyConsecutiveCounter++;\n        } else {\n            // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n            howManyConsecutiveCounter = 1;\n        }\n    }\n\n    // Check vertical\n    let currColIdx = lastSquareIdx % 7;\n    const outOfBoundsIdx = 42;\n    howManyConsecutiveCounter = 1; // always starts at 1 because each piece counts as one consecutive piece\n    for (currColIdx; currColIdx < outOfBoundsIdx ; currColIdx += 7) {\n        if (howManyConsecutiveCounter === 4) {\n            return board[currColIdx]; // winner has been found, return the winner\n        } else if (currColIdx + 7 < outOfBoundsIdx && board[currColIdx] !== null && board[currColIdx] === board[currColIdx + 7]) {\n            howManyConsecutiveCounter++;\n        } else {\n            // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n            howManyConsecutiveCounter = 1;\n        }\n    }\n\n    // Check Diagonal\n\n    // start with BOTTOM-LEFT TO TOP-RIGHT relative to the lastSquareIdx\n    // get bottom left squares as indices\n    const rightColumnIdx = new Set([6, 13, 20, 27, 34, 41]);\n    const leftColumnIdx = new Set([0, 7, 14, 21, 28, 35]);\n    const bottomLeftTopRightIdx = [];\n    let i = 1;\n    while (lastSquareIdx - 7 * i >= 0) {\n        if (lastSquareIdx - 7 * i - i >= 0 && !rightColumnIdx.has(lastSquareIdx - 7 * i - i)) {\n            bottomLeftTopRightIdx.unshift(lastSquareIdx - 7 * i - i);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    // push the selectedSquareIdx into the bottomLeftTopRightIdx array\n    bottomLeftTopRightIdx.push(lastSquareIdx);\n\n    // get the top right squares as indices\n    i = 1;\n    while (lastSquareIdx + 7 * i < 42) {\n        if (lastSquareIdx + 7 * i + i < 42 && !leftColumnIdx.has(lastSquareIdx + 7 * i + i)) {\n            bottomLeftTopRightIdx.push(lastSquareIdx + 7 * i + i);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    // check to see if there is a 4-in-a-row from bottom left to top right\n    howManyConsecutiveCounter = 1;\n    for (let i = 0; i < bottomLeftTopRightIdx.length; i++) {\n        if (howManyConsecutiveCounter === 4) {\n            return board[bottomLeftTopRightIdx[i]]; // winner has been found, return the winner\n        } else if (board[bottomLeftTopRightIdx[i]] !== null && board[bottomLeftTopRightIdx[i]] === board[bottomLeftTopRightIdx[i + 1]]) {\n            howManyConsecutiveCounter++;\n        } else {\n            // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n            howManyConsecutiveCounter = 1;\n        }\n    }\n\n    // NOW DO THE OTHER DIAGONAL... BOTTOM-RIGHT TO TOP-LEFT relative to the lastSquareIdx\n    // get bottom right squares as indices\n    const bottomRightTopLeftIdx = [];\n    i = 1;\n    while (lastSquareIdx - 7 * i >= 0) {\n        if (!leftColumnIdx.has(lastSquareIdx - 7 * i + i)) {\n            bottomRightTopLeftIdx.unshift(lastSquareIdx - 7 * i + i);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    // push the selectedSquareIdx into the bottomRightTopLeftIdx array\n    bottomRightTopLeftIdx.push(lastSquareIdx);\n\n    // get the top left squares as indices\n    i = 1;\n    while (lastSquareIdx + 7 * i < 42) {\n        if (!rightColumnIdx.has(lastSquareIdx + 7 * i - i)) {\n            bottomRightTopLeftIdx.push(lastSquareIdx + 7 * i - i);\n            i++;\n        } else {\n            break;\n        }\n    }\n\n    // check to see if there is a 4-in-a-row from bottom right to top left\n    howManyConsecutiveCounter = 1;\n    for (let i = 0; i < bottomRightTopLeftIdx.length; i++) {\n        if (howManyConsecutiveCounter === 4) {\n            return board[bottomRightTopLeftIdx[i]]; // winner has been found, return the winner\n        } else if (board[bottomRightTopLeftIdx[i]] !== null && board[bottomRightTopLeftIdx[i]] === board[bottomRightTopLeftIdx[i + 1]]) {\n            howManyConsecutiveCounter++;\n        } else {\n            // either the loop ends and there is no winner found here OR the next adjacent piece is a different color\n            howManyConsecutiveCounter = 1;\n        }\n    }\n\n    return null;\n}\n\nfunction idxOfMaxOfArr(arr) {\n    let max = arr[0];\n    let maxIdx = 0;\n    for (let i = 0; i < arr.length; i++) {\n        if (arr[i] > max) {\n            max = arr[i]\n            maxIdx = i;\n        }\n    }\n    return maxIdx;\n}\n\nfunction minimax(board, depth, maximizingPlayer, minimizingPlayer) {\n    /**\n     * minimax algorithm to determine how the ai will make its move\n     * refer to the pseudocode on wikipedia\n     */\n\n    // get all the possible moves that the player can drop into\n    // this should be an array with the indices\n    const possibleMovesArr = [0,1,2,3,4,5,6].map(idx => findLegalSquare(board, idx)).filter(idx => idx !== -1);\n    const scoresForPossibleMovesArr = possibleMovesArr.map(idx => calculateScoreForMove(board, idx, maximizingPlayer, minimizingPlayer));\n    alert(scoresForPossibleMovesArr);\n    return possibleMovesArr[idxOfMaxOfArr(scoresForPossibleMovesArr)];\n}\n\nexport default minimax;"]},"metadata":{},"sourceType":"module"}